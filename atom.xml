<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Let&#39;s go for a walk around the world - zuo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-23T16:08:41.363Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>12306火车票查询</title>
    <link href="http://yoursite.com/2018/06/02/12306%E8%BD%A6%E7%A5%A8%E6%9F%A5%E8%AF%A2/"/>
    <id>http://yoursite.com/2018/06/02/12306车票查询/</id>
    <published>2018-06-02T13:00:00.000Z</published>
    <updated>2018-07-23T16:08:41.363Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过12306官网的几个接口来获取火车余票信息，结合邮件模块发现余票时就发送邮件给自己提示，虽然达不到黄牛那种毫秒级别，秒级别的速度，在不繁忙的线路和时间段还是有点用处。<br><strong>注</strong>：目前版本只做了余票查询，后期有时间再加入票价信息等，由于12306登陆验证码以及登陆态的失效时间实在变态，要实现完全自动化还需购买付费人工打码服务，因此暂时不不计划做自动购票功能。</p><h2 id="查询余票接口"><a href="#查询余票接口" class="headerlink" title="查询余票接口"></a>查询余票接口</h2><p>首先打开12306官网，并进入<a href="https://kyfw.12306.cn/otn/leftTicket/init" target="_blank" rel="external"><u>余票查询</u></a>页面，同时开启chrome浏览器F12控制台，以北京到上海为例，搜索2018年6月5日的余票信息，点击搜索按钮，可以在控制台发送了一条GET请求，请求结果以json字符串的形式放回，里面有查询到的余票信息。</p><p><img src="http://otlbf411d.bkt.clouddn.com/18-6-5/5071589.jpg" alt=""></p><p>通过python-requests来请求一下这个接口，比较意外的是这个接口并没有校验header信息，因此我们不用添加header。在测试中发现虽然12306官网主页提供了证书下载，但是这个https请求并不是必须校验证书，将requests方法中的verify参数设置为False取消校验也能正常返回结果。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> requests</div><div class="line"></div><div class="line">url = <span class="string">'https://kyfw.12306.cn/otn/leftTicket/query?leftTicketDTO.train_date=2018-06-05&amp;leftTicketDTO.from_station=BJP&amp;leftTicketDTO.to_station=SHH&amp;purpose_codes=ADULT'</span></div><div class="line">requests.packages.urllib3.disable_warnings()</div><div class="line">r = requests.get(url,verify=<span class="keyword">False</span>).json()</div><div class="line">yupiao = r[<span class="string">'data'</span>][<span class="string">'result'</span>]</div><div class="line">print(yupiao)</div></pre></td></tr></table></figure></p><p>如下图返回结果是个列表，每一个元素就是一条火车线路，包含始发站代码，终点站代码，发车时间，每种座位的余票等信息，通过” | “分隔，需要注意的是每种座位的余票数量与网页展示的位置前后顺序并不是一一对应的，这个花了不少时间来确定每个对应关系。<br><img src="http://otlbf411d.bkt.clouddn.com/18-6-5/17290359.jpg" alt=""></p><p>将上一步返回结果放入循环中，每一个元素按照” | “符号分割，并从分割后的列表中依次取出需要的内容（城市代码，时间，车次，作为余票等信息）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> requests</div><div class="line"><span class="keyword">from</span> tabulate <span class="keyword">import</span> tabulate</div><div class="line"></div><div class="line"><span class="comment">#查询余票</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">()</span>:</span></div><div class="line">    url = <span class="string">'https://kyfw.12306.cn/otn/leftTicket/query?leftTicketDTO.train_date=2018-06-05&amp;leftTicketDTO.from_station=BJP&amp;leftTicketDTO.to_station=SHH&amp;purpose_codes=ADULT'</span></div><div class="line">    requests.packages.urllib3.disable_warnings()</div><div class="line">    r = requests.get(url,verify=<span class="keyword">False</span>).json()</div><div class="line">    yupiao = r[<span class="string">'data'</span>][<span class="string">'result'</span>]</div><div class="line"></div><div class="line">    table_header = [<span class="string">'车次'</span>,<span class="string">'始发站'</span>,<span class="string">'终点站'</span>,<span class="string">'始发时间'</span>,<span class="string">'到站时间'</span>,<span class="string">'历时'</span>,<span class="string">'商务特等座'</span>,<span class="string">'一等座'</span>,<span class="string">'二等座'</span>,<span class="string">'高级软卧'</span>,<span class="string">'软卧'</span>,<span class="string">'动卧'</span>,<span class="string">'硬卧'</span>,<span class="string">'软座'</span>,<span class="string">'硬座'</span>,<span class="string">'无座'</span>]  <span class="comment">#表格头</span></div><div class="line"></div><div class="line">    table_data = []  <span class="comment">#数据添加至列表，作为表格的主体内容</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> yupiao:</div><div class="line">        a = i.split(<span class="string">'|'</span>)           <span class="comment">#分割字符串，a是个列表</span></div><div class="line"></div><div class="line">        is_null = a[<span class="number">0</span>]             <span class="comment">#判断是否有票</span></div><div class="line">        train_code = a[<span class="number">3</span>]          <span class="comment">#车次</span></div><div class="line">        start_city_code = a[<span class="number">4</span>]     <span class="comment">#始发站城市代码</span></div><div class="line">        end_city_code = a[<span class="number">5</span>]       <span class="comment">#终点站城市代码</span></div><div class="line">        start_time = a[<span class="number">8</span>]          <span class="comment">#终点站开始时间</span></div><div class="line">        end_time = a[<span class="number">9</span>]            <span class="comment">#终点站到达时间</span></div><div class="line">        total_time = a[<span class="number">10</span>]         <span class="comment">#总共历时</span></div><div class="line">        shangwutedeng = a[<span class="number">32</span>]      <span class="comment">#商务特等座</span></div><div class="line">        yideng = a[<span class="number">31</span>]             <span class="comment">#一等座</span></div><div class="line">        erdeng = a[<span class="number">30</span>]             <span class="comment">#二等座</span></div><div class="line">        gaojiruanwo = a[<span class="number">21</span>]        <span class="comment">#高级软卧</span></div><div class="line">        ruanwo = a[<span class="number">23</span>]             <span class="comment">#软卧</span></div><div class="line">        dongwo = a[<span class="number">33</span>]             <span class="comment">#动卧</span></div><div class="line">        yingwo = a[<span class="number">28</span>]             <span class="comment">#硬卧</span></div><div class="line">        ruanzuo = a[<span class="number">24</span>]            <span class="comment">#软座</span></div><div class="line">        yingzuo = a[<span class="number">29</span>]            <span class="comment">#硬座</span></div><div class="line">        wuzuo = a[<span class="number">26</span>]              <span class="comment">#无座</span></div><div class="line"></div><div class="line">        <span class="comment">#添加到元组</span></div><div class="line">        yupiao_tuple = (train_code,start_city_code,end_city_code,start_time,end_time,total_time,shangwutedeng,yideng,erdeng,gaojiruanwo,ruanwo,dongwo,yingwo,ruanzuo,yingzuo,wuzuo)</div><div class="line">        table_data.append(yupiao_tuple)</div><div class="line">    print(tabulate(table_data,headers=table_header,tablefmt=<span class="string">'grid'</span>))</div></pre></td></tr></table></figure></p><p>在上面代码中使用了<code>tabulate</code>库，它可以把结果输出成易读的表格样式，<a href="https://python-book.readthedocs.io/zh_CN/latest/libs/tabulate.html" target="_blank" rel="external"><u>更多使用方法点击这里</u></a>。</p><p><img src="http://otlbf411d.bkt.clouddn.com/18-6-5/29355983.jpg" alt=""></p><h2 id="参数化准备"><a href="#参数化准备" class="headerlink" title="参数化准备"></a>参数化准备</h2><p>再回头看之前请求的URL，这个GET请求有四个请求参数，分别代表如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">leftTicketDTO.train_date       --&gt;      乘车日期</div><div class="line">leftTicketDTO.from_station     --&gt;      始发站代码(例如北京北：VAP)</div><div class="line">leftTicketDTO.to_station       --&gt;      终点站代码(例如上海虹桥：AOH)</div><div class="line">purpose_codes                  --&gt;      车票类型(普通票：ADULT，学生票：0X00)</div></pre></td></tr></table></figure></p><p>第一个和第四个参数好填写，始发站和终点站代码我们现在并没有对应的表，不知道每个站点对应的代码，在网站上找一下。我们在页面上手动修改始发站和终点站的时候发现并没有发送新的https请求，可以猜测所有的站点信息应该是在一个js文件里面，然后通过页面的js方法来选择不同的站名，现在F12控制台切换至JS模块下，刷新这个余票查询页面。</p><p><img src="http://otlbf411d.bkt.clouddn.com/18-6-5/11512788.jpg" alt=""><br>从上图可以看到刷新页面后有个名称为station_name.js的js文件，单击一看果然是存放了所有的站点信息，将这个文件的url复制重新打开一个页面可以看到，火车站点信息放在station_name变量后面的字符串，中间有很多” | “作为分隔符，观察发现每五个符号分隔的内容为一组，刚好是一个站点的信息。</p><p><img src="http://otlbf411d.bkt.clouddn.com/18-6-5/80561012.jpg" alt=""></p><p>我们需要把这个很长的字符串重新分隔成我们想要的格式，将这个很长的字符串全部复制到一个py文件,通过以下函数来处理：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#查询每个站点名称/拼音/缩写/代码</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_station_code</span><span class="params">()</span>:</span></div><div class="line">    code = all_station.split(<span class="string">'|'</span>)   <span class="comment">#字符串的所有信息按照"|"符号分割，结果是一个列表</span></div><div class="line">    n = <span class="number">5</span>  <span class="comment"># 大列表中几个数据组成一个小列表，每五个元素为一个站点信息组合</span></div><div class="line">    station_code = [code[i:i + n] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(code), n)]  <span class="comment">#每一个火车站点信息为一个元素放在此列表</span></div><div class="line">    print(station_code)</div></pre></td></tr></table></figure></p><p>执行结果如下，长字符串已经被转换成一个大列表，列表中的每个元素分别是一个小列表，小列表包含火车站点的五个信息，其中最后一个小列表只有一个元素，应该是备用的字段现在没有用，直接删除。<br><img src="http://otlbf411d.bkt.clouddn.com/18-6-5/74374072.jpg" alt=""></p><h2 id="用户输入判断"><a href="#用户输入判断" class="headerlink" title="用户输入判断"></a>用户输入判断</h2><p>上一步已经整理好了所有的火车站点信息，下面代码实现用户输入火车站名时找到对应的站点代码，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#根据用户输入的站点名或者缩写在站点列表中检索对应的代码</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">retrieve_station</span><span class="params">()</span>:</span></div><div class="line">    a = input(<span class="string">'请输入始发站、终点站、日期，用一个空格隔开，按回车键查询，参考格式：北京 上海 20180605\n:'</span>)</div><div class="line">    start_city = a.split(<span class="string">' '</span>)[<span class="number">0</span>]</div><div class="line">    end_city = a.split(<span class="string">' '</span>)[<span class="number">1</span>]</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        date = str(a.split(<span class="string">' '</span>)[<span class="number">2</span>])</div><div class="line">        <span class="keyword">if</span> len(date) == <span class="number">8</span>:   <span class="comment">#用户日期是否是8位正整数</span></div><div class="line">            newdate = date[:<span class="number">4</span>] + <span class="string">'-'</span> + date[<span class="number">4</span>:<span class="number">6</span>] + <span class="string">'-'</span> + date[<span class="number">6</span>:]  <span class="comment">#转换为查询接口所需的日期参数格式，例如2018-06-08</span></div><div class="line">            <span class="keyword">break</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            print(<span class="string">'日期输入有误，请重新输入'</span>)</div><div class="line"></div><div class="line">    <span class="comment">#检索始发站代码</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> station_code:  <span class="comment">#station_code就是上一步整理好的站点列表</span></div><div class="line">        <span class="keyword">if</span> start_city == i[<span class="number">1</span>]:</div><div class="line">            start_city_code = i[<span class="number">2</span>]  <span class="comment">#始发站代码</span></div><div class="line">            <span class="keyword">break</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">pass</span></div><div class="line"></div><div class="line">    <span class="comment">#检索目的地代码</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> station_code:   <span class="comment">#station_code就是上一步整理好的站点列表</span></div><div class="line">        <span class="keyword">if</span> end_city == i[<span class="number">1</span>]:</div><div class="line">            end_city_code = i[<span class="number">2</span>]  <span class="comment">#终点站代码</span></div><div class="line">            <span class="keyword">break</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">pass</span></div><div class="line">    <span class="keyword">return</span> newdate,start_city_code,end_city_code</div></pre></td></tr></table></figure></p><p>上面的函数执行后返回日期,始发站代码，终点站代码，将它们格式化传到请求的URL中重新请求就得到了想要的结果，修改之前的查询余票函数如下。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#查询余票</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">()</span>:</span></div><div class="line">    station_info = retrieve_station()</div><div class="line">    url = <span class="string">'https://kyfw.12306.cn/otn/leftTicket/query?leftTicketDTO.train_date=%s&amp;leftTicketDTO.from_station=%s&amp;leftTicketDTO.to_station=%s&amp;purpose_codes=ADULT'</span> %(station_info[<span class="number">0</span>],station_info[<span class="number">1</span>],station_info[<span class="number">2</span>])</div><div class="line">    ...</div></pre></td></tr></table></figure></p><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="http://otlbf411d.bkt.clouddn.com/18-6-5/40413405.jpg" alt=""></p><font color="white">xx</font><p><div class="paginator"><a href="/archives/" class="all">more</a></div><footer><div class="copyright container"><p>    .</p></div></footer></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;通过12306官网的几个接口来获取火车余票信息，结合邮件模块发现余票时就发送邮件给自己提示，虽然达不到黄牛那种毫秒级别，秒级别的速度，在不繁
      
    
    </summary>
    
    
      <category term="测试" scheme="http://yoursite.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="接口测试" scheme="http://yoursite.com/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>requests中HTTPS请求的处理</title>
    <link href="http://yoursite.com/2018/04/27/requests%E4%B8%ADHTTPS%E8%AF%B7%E6%B1%82%E7%9A%84%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2018/04/27/requests中HTTPS请求的处理/</id>
    <published>2018-04-27T12:30:00.000Z</published>
    <updated>2018-07-23T16:09:50.109Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在接口测试或者爬虫的时候经常遇到HTTPS的请求，直接用python中requests方法请求的话会可能出现如下报错。<br><img src="http://otlbf411d.bkt.clouddn.com/18-4-28/61998649.jpg" alt=""></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>在requests添加<code>verify</code>参数，verify是用来验证SSL证书开关，默认是True，如果不想验证的话将它设置为False<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">r = requests.get(url,verify=<span class="keyword">False</span>)</div><div class="line">print(r.status_code)</div></pre></td></tr></table></figure></p><p><img src="http://otlbf411d.bkt.clouddn.com/18-4-28/39975195.jpg" alt=""></p><p>现在已经不影响请求的结果，但是每次请求的时候会出现警告，看着比较不舒服。想要去掉这个警告提示，需要在请求之前加上如下代码。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">requests.packages.urllib3.disable_warnings()</div><div class="line">r = requests.get(url,verify=<span class="keyword">False</span>)</div><div class="line">print(r.status_code)</div></pre></td></tr></table></figure></p><p><img src="http://otlbf411d.bkt.clouddn.com/18-4-28/28970763.jpg" alt=""></p><font color="white">xx</font><p><div class="paginator"><a href="/archives/" class="all">more</a></div><footer><div class="copyright container"><p>    .</p></div></footer></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在接口测试或者爬虫的时候经常遇到HTTPS的请求，直接用python中requests方法请求的话会可能出现如下报错。&lt;br&gt;&lt;img sr
      
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="接口测试" scheme="http://yoursite.com/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>python小说爬虫</title>
    <link href="http://yoursite.com/2018/04/25/python%E5%B0%8F%E8%AF%B4%E7%88%AC%E8%99%AB/"/>
    <id>http://yoursite.com/2018/04/25/python小说爬虫/</id>
    <published>2018-04-25T12:30:00.000Z</published>
    <updated>2018-07-23T16:17:50.022Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很久没有写爬虫了，最近接到一个抓取小说的项目顺便做此纪录练练手，之后工作中可能也会有部分场景要用到爬虫，爬取竞争对手进行数据分析什么的。<br>目标网站：<a href="http://www.xxsy.net/" target="_blank" rel="external"><strong>潇湘书院</strong></a><br>环境准备：</p><ul><li>python3</li><li>requests库</li><li>BeautifulSoup库</li></ul><h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h2><p>抓取这个小说网站免费板块的所有内容，查看页面发现这个板块一共有6697页，每页有20本小说，那整体思路就是先抓取每页的20个小说名称和url，然后进入每本小说的阅读地址，拿到每一个章节的标题和url，抓取每章节的正文内容并写到本地txt文本中。<br><img src="123" alt=""></p><h2 id="单页分析"><a href="#单页分析" class="headerlink" title="单页分析"></a>单页分析</h2><p>这里请求使用requests，解析页面用非常方便的BeautifulSoup，在一个文章标题上右键检查，在高亮的这条a标签右键，copy selector，通过这条selector来定位BeautifulSoup解析后小说所在的位置。<br><img src="http://otlbf411d.bkt.clouddn.com/18-4-26/95059112.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">body &gt; div.content &gt; div &gt; div &gt; div.inner-mainbar &gt; div.search-result &gt; div.result-list &gt; ul &gt; li:nth-child(1) &gt; div &gt; h4 &gt; a</div></pre></td></tr></table></figure></p><p>其中<code>li:nth-child(1)</code>很明显是指这个小说在当前页面小说列表中排列第一个，我们想要本页面所有的20本小说，所以就删掉这个<code>:nth-child(1)</code>，再将selector语句精简一下只要能定位到即可，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">div.result-list &gt; ul &gt; li &gt; div &gt; h4 &gt; a</div></pre></td></tr></table></figure></p><p>然后将它写入代码，print查看一下结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> requests,os</div><div class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</div><div class="line"></div><div class="line">webdata = requests.get(<span class="string">'http://www.xxsy.net/search?vip=0&amp;sort=2'</span>)</div><div class="line">soup = BeautifulSoup(webdata.text,<span class="string">'lxml'</span>)</div><div class="line">books = soup.select(<span class="string">'div.result-list &gt; ul &gt; li &gt; div &gt; h4 &gt; a'</span>)</div><div class="line">print(books)</div></pre></td></tr></table></figure><p><img src="http://otlbf411d.bkt.clouddn.com/18-4-26/26352205.jpg" alt=""><br>结果是一个列表，列表中有20个元素，分别对应的20个小说，我们想要的是每个元素中href后面的链接和小说的名字，用循环提取出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="keyword">for</span> book <span class="keyword">in</span> books:</div><div class="line">    bookname = book.text</div><div class="line">    bookurl = <span class="string">'http://www.xxsy.net'</span> + book.get(<span class="string">'href'</span>)</div><div class="line">    bookid = book.get(<span class="string">'href'</span>).split(<span class="string">'/'</span>)[<span class="number">-1</span>].split(<span class="string">'.'</span>)[<span class="number">0</span>]</div><div class="line">    print(bookname,bookurl,bookid)</div></pre></td></tr></table></figure><p><img src="http://otlbf411d.bkt.clouddn.com/18-4-26/86095250.jpg" alt=""><br>这样就很简单的拿到了单个页面20本小说的标题和url地址，可以看到上面我把地址中的一串数字用单独取出来了，这个数字其实就是小说对应的唯一ID，后面要用到。</p><h2 id="章节分析"><a href="#章节分析" class="headerlink" title="章节分析"></a>章节分析</h2><p>点击一个小说进入详情页面，切换至”作品目录”下可以看到所有的章节，这时候在一个章节上右键检查，跟上面方法一样，同样可以很简单的获取到该小说所有章节的名称和url地址以及章节ID。<br><img src="http://otlbf411d.bkt.clouddn.com/18-4-26/51873134.jpg" alt=""></p><p>为了在一篇文章介绍尽可能多的方法，这里我不用上面这个地方来获取章节信息，从另一个地方进入。点击“开始阅读”进入第一章节的正文，在页面的左边可以看到一个“目录”按钮，点看以后就能看到所有的章节名称了。然而在这些章节名称上右键发现当前页面禁用了鼠标右键功能，无法检查元素当然也就不能copy它的selector。<br><img src="http://otlbf411d.bkt.clouddn.com/18-4-26/63797573.jpg" alt=""></p><p>这种按钮的点击肯定是向服务器发送了请求的，打开fiddler进行抓包，再次点击目录按钮，此时可以看到这个请求已经被成功捕获，点击这条请求查看详细信息，这个接口的功能就是查询所有的章节信息。<br><img src="http://otlbf411d.bkt.clouddn.com/18-4-26/17982944.jpg" alt=""></p><p>真实的请求地址是<code>http://www.xxsy.net/partview/GetChapterListNoSub?bookid=945608&amp;isvip=0</code>，其中bookid就是我们前面找到的bookid，这里可以做成参数化依次传入其他小说的ID。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">url = <span class="string">'http://www.xxsy.net/partview/GetChapterListNoSub?bookid=945608&amp;isvip=0'</span></div><div class="line">titles = BeautifulSoup(requests.get(url).text,<span class="string">'lxml'</span>).select(<span class="string">'ul &gt; li &gt; a'</span>)</div><div class="line"><span class="keyword">for</span> title <span class="keyword">in</span> titles:</div><div class="line">    titlename = title.text  <span class="comment">#章节名称</span></div><div class="line">    titleurl = <span class="string">'http://www.xxsy.net'</span> + title.get(<span class="string">'href'</span>)   <span class="comment">#章节地址</span></div><div class="line">    print(titlename,titleurl)</div></pre></td></tr></table></figure></p><p><img src="http://otlbf411d.bkt.clouddn.com/18-4-26/53687066.jpg" alt=""></p><h2 id="正文下载"><a href="#正文下载" class="headerlink" title="正文下载"></a>正文下载</h2><p>上一步取到的titleurl是每一章节的阅读地址，直接requests请求并解析拿到正文内容<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">contents = BeautifulSoup(requests.get(titleurl).text, <span class="string">'lxml'</span>).select(<span class="string">'div#auto-chapter &gt; p'</span>)   <span class="comment">#正文内容</span></div></pre></td></tr></table></figure></p><p><img src="http://otlbf411d.bkt.clouddn.com/18-4-26/83734461.jpg" alt=""><br>返回结果是一个列表，每一个元素是一个段落，将每一段内容前后无用的标签剔除并写到本地的txt文本，写入方式为<code>a+</code>,每次写入时在后面追加，不会覆盖之前的内容，文本自动按照前面获取到的小说名来命名。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="keyword">for</span> content <span class="keyword">in</span> contents:</div><div class="line">    content = str(content).replace(<span class="string">'&lt;p&gt;'</span>, <span class="string">'\n'</span>).replace(<span class="string">'&lt;/p&gt;'</span>, <span class="string">''</span>)</div><div class="line">    f = open(path + <span class="string">'%s.txt'</span> % bookname, <span class="string">'a+'</span>)</div><div class="line">    f.write(content)</div><div class="line">    f.close()</div></pre></td></tr></table></figure></p><p><img src="http://otlbf411d.bkt.clouddn.com/18-4-26/31951196.jpg" alt=""></p><p>到此为止三个步骤已经完成，可以顺利的爬下一个章节的内容了，现在通过几个for循环将这几个步骤整合，就可以源源不断的开始下载小说了。<br><img src="http://otlbf411d.bkt.clouddn.com/18-4-26/272032.jpg" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line"><span class="keyword">import</span> requests,time,os</div><div class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</div><div class="line"></div><div class="line">path = <span class="string">r'C:\Users\lipei\Desktop\潇湘书院爬虫\小说\\'</span>               <span class="comment">#本地存放小说的路径</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_books</span><span class="params">(url)</span>:</span></div><div class="line">    webdata = requests.get(url,timeout=<span class="number">60</span>)   </div><div class="line">    soup = BeautifulSoup(webdata.text,<span class="string">'lxml'</span>)</div><div class="line">    books = soup.select(<span class="string">'div.result-list &gt; ul &gt; li &gt; div &gt; h4 &gt; a'</span>)</div><div class="line">    <span class="keyword">for</span> book <span class="keyword">in</span> books:</div><div class="line">        bookid = book.get(<span class="string">'href'</span>).split(<span class="string">'/'</span>)[<span class="number">-1</span>].split(<span class="string">'.'</span>)[<span class="number">0</span>]   <span class="comment">#小说ID作为下一个请求ur中的参数</span></div><div class="line">        bookname = book.text                                     <span class="comment">#小说名称</span></div><div class="line">        bookurl = <span class="string">'http://www.xxsy.net'</span> + book.get(<span class="string">'href'</span>)       <span class="comment">#小说url地址</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> bookname+<span class="string">'.txt'</span> <span class="keyword">in</span> oldlists:                          <span class="comment">#判断是否已经下载过，若存在则跳过</span></div><div class="line">            <span class="keyword">continue</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">pass</span></div><div class="line"></div><div class="line">        print(<span class="string">'=====================正在下载【'</span> + bookname + <span class="string">'】====================='</span>)</div><div class="line">        url = <span class="string">'http://www.xxsy.net/partview/GetChapterListNoSub?bookid=%s&amp;isvip=0'</span> % bookid</div><div class="line">        titles = BeautifulSoup(requests.get(url,timeout=<span class="number">60</span>).text,<span class="string">'lxml'</span>).select(<span class="string">'ul &gt; li &gt; a'</span>)</div><div class="line"></div><div class="line">        <span class="keyword">for</span> title <span class="keyword">in</span> titles:</div><div class="line">            titleurl = <span class="string">'http://www.xxsy.net'</span> + title.get(<span class="string">'href'</span>)  <span class="comment">#章节url地址</span></div><div class="line">            titlename = title.text                                <span class="comment">#章节名称</span></div><div class="line">            <span class="comment"># print(titlename,titleurl)</span></div><div class="line">            <span class="keyword">try</span>:</div><div class="line">                f = open(path + <span class="string">'%s.txt'</span> % bookname, <span class="string">'a+'</span>)        <span class="comment">#章节名称写到txt文本</span></div><div class="line">                f.write(<span class="string">'\n'</span>*<span class="number">2</span> + titlename + <span class="string">'\n'</span>)</div><div class="line">                f.close()</div><div class="line">            <span class="keyword">except</span>:</div><div class="line">                <span class="keyword">pass</span></div><div class="line"></div><div class="line">            contents = BeautifulSoup(requests.get(titleurl,timeout=<span class="number">60</span>).text, <span class="string">'lxml'</span>).select(<span class="string">'div#auto-chapter &gt; p'</span>)</div><div class="line">            <span class="keyword">for</span> content <span class="keyword">in</span> contents:</div><div class="line">                content = str(content).replace(<span class="string">'&lt;p&gt;'</span>, <span class="string">'\n'</span>).replace(<span class="string">'&lt;/p&gt;'</span>, <span class="string">''</span>)</div><div class="line">                <span class="keyword">try</span>:</div><div class="line">                    f = open(path + <span class="string">'%s.txt'</span> % bookname, <span class="string">'a+'</span>)   <span class="comment">#正文内容卸载txt文本，紧接在章节名称的下面</span></div><div class="line">                    f.write(content)</div><div class="line">                    f.close()</div><div class="line">                <span class="keyword">except</span>:</div><div class="line">                    <span class="keyword">pass</span></div><div class="line">            print(titlename + <span class="string">'[已下载]'</span>)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    urls = [<span class="string">'http://www.xxsy.net/search?vip=0&amp;sort=2&amp;pn=&#123;&#125;'</span>.format(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6697</span>)]   <span class="comment">#免费板块每一页的url通过最后的pn参数控制</span></div><div class="line">    <span class="keyword">global</span> oldlists</div><div class="line">    oldlists = os.listdir(path)        <span class="comment">#爬虫开始之前检查当前目录已有的文件</span></div><div class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</div><div class="line">        get_books(url)</div><div class="line"></div><div class="line">        <span class="comment">#控制每天爬取的数量，达到要求后停止任务，通过任务开始前后目录中的文件数量相减来判断</span></div><div class="line">        newlists = os.listdir(path)</div><div class="line">        num = len(newlists) - len(oldlists)</div><div class="line">        <span class="keyword">if</span> num &gt;= <span class="number">20</span>:</div><div class="line">            print(<span class="string">'今日任务下载完毕，今日下载小说%d本'</span> % num)</div><div class="line">            <span class="keyword">break</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">pass</span></div></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>在测试过程中发现短时间持续请求该网站的话会可能被服务器拒绝，但是并没有封禁IP，这可能是这个网站唯一的反爬措施了，然而并没有卵用，将请求放在一个无限循环里面，若被拒绝就自动重连，连上以后跳出循环。<br>后面如果遇到封禁IP的网站再讲如何通过更换IP来规避。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        webdata = requests.get(url,timeout=<span class="number">60</span>)</div><div class="line">        <span class="keyword">break</span>      <span class="comment">#连接成功就跳出循环</span></div><div class="line">    <span class="keyword">except</span>:</div><div class="line">        time.sleep(<span class="number">3</span>)</div></pre></td></tr></table></figure></p><font color="white">xx</font><font color="#0099ff" size="6" face="黑体"><br>                          &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href="http://zuowangwang.wang" target="_blank" rel="external">主页</a>        &emsp;&emsp;<a href="http://zuowangwang.wang/archives" target="_blank" rel="external">目录</a><br>              </font>    ]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;很久没有写爬虫了，最近接到一个抓取小说的项目顺便做此纪录练练手，之后工作中可能也会有部分场景要用到爬虫，爬取竞争对手进行数据分析什么的。&lt;b
      
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>常用小命令随机更新</title>
    <link href="http://yoursite.com/2018/01/30/%E5%B8%B8%E7%94%A8%E5%B0%8F%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/01/30/常用小命令/</id>
    <published>2018-01-30T01:30:00.000Z</published>
    <updated>2018-07-23T16:20:57.807Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在平时的测试工作或者自己闲时做的项目中，有一些操作可能是经常用到，每次重复写比较费时，例如批量生成，复制一些文件、文件夹，某个web页面的自动化等，其中有些是Windows系统命令，有些是python的命令，特开一贴记录，将常用的操作都通过python来调用执行，内容可能比较杂，通过关键字搜索找到需要的，长期更新。</p><h2 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> time,os,requests</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">mkdir</span><span class="params">()</span>:</span></div><div class="line">    <span class="string">'''批量创建文件夹'''</span></div><div class="line">    path = input(<span class="string">'请输入需要创建文件夹的上级路径：'</span>)</div><div class="line">    dirs = [path + <span class="string">'/&#123;&#125;'</span>.format(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>)]</div><div class="line">    <span class="keyword">for</span> dir <span class="keyword">in</span> dirs:</div><div class="line">        os.makedirs(dir)</div><div class="line">        print(dirs.index(dir)+<span class="number">1</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_file</span><span class="params">()</span>:</span></div><div class="line">    <span class="string">'''批量创建文件'''</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">        cmd = <span class="string">r'fsutil file createnew D:\test\10G-&#123;&#125;.txt 10737418240'</span>.format(i)  <span class="comment"># 10737418240代表10G大小，单位是b，根据需要修改其他大小</span></div><div class="line">        os.system(cmd)</div><div class="line">        print(<span class="string">'第%d个文件创建完毕'</span>%i)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">cy_file</span><span class="params">()</span>:</span></div><div class="line">    <span class="string">'''批量复制文件'''</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">100</span>):</div><div class="line">        cmd = <span class="string">r'copy E:\test1\0001.txt E:\test2\000&#123;&#125;.txt'</span>.format(i) <span class="comment">#使用时修改原路径和目标路径</span></div><div class="line">        os.system(cmd)</div><div class="line">        print(<span class="string">'%d.txt'</span> % i + <span class="string">' 复制完毕'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_port</span><span class="params">()</span>:</span></div><div class="line">    <span class="string">'''查询端口占用'''</span></div><div class="line">    port = input(<span class="string">'请输入端口号:'</span>)</div><div class="line">    pid = os.popen(<span class="string">r'netstat -ano | findstr %s'</span> % port).read().split(<span class="string">' '</span>)[<span class="number">-1</span>]  <span class="comment"># 按照空格分隔，只取最后的pid号</span></div><div class="line">    task = os.popen(<span class="string">r'tasklist | findstr %s'</span> % pid).read()  <span class="comment"># 根据pid找到对应的程序</span></div><div class="line">    print(<span class="string">'占用此端口的程序是： '</span> + task)</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure><font color="white">xx</font><p><header><div class="container"><a href="/" class="logo"><img src="/logo.png"></a></div></header></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在平时的测试工作或者自己闲时做的项目中，有一些操作可能是经常用到，每次重复写比较费时，例如批量生成，复制一些文件、文件夹，某个web页面的自
      
    
    </summary>
    
    
      <category term="测试" scheme="http://yoursite.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="cmd" scheme="http://yoursite.com/tags/cmd/"/>
    
      <category term="系统命令" scheme="http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>python读写excel表格</title>
    <link href="http://yoursite.com/2018/01/29/python%E8%AF%BB%E5%86%99excel%E8%A1%A8%E6%A0%BC/"/>
    <id>http://yoursite.com/2018/01/29/python读写excel表格/</id>
    <published>2018-01-29T05:03:00.000Z</published>
    <updated>2018-07-23T15:57:55.562Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间接口自动化测试用excel表来管理用例，读取写入的时候遇到了一些小坑，在此做记录。<br>操作excel表的python库有很多，这里只介绍自己使用中感觉兼容性最好最容易使用的xlrd和xlwt，使用方法比较简单，直接查看以下demo即可。</p><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#首先导入xlrd模块</span></div><div class="line"><span class="keyword">import</span> xlrd</div><div class="line"></div><div class="line">workbook = xlrd.open_workbook(<span class="string">'E:/interface_test/test_data.xls'</span>)  <span class="comment"># 打开测试数据表</span></div><div class="line">table1 = workbook.sheets()[<span class="number">0</span>]  <span class="comment"># 选择该excel文件的第一张表，序号从0开始</span></div><div class="line">login_url = table1.cell(<span class="number">0</span>,<span class="number">1</span>).value <span class="comment">#获取登陆url，第一行第二列</span></div><div class="line">name = table1.cell(<span class="number">2</span>,<span class="number">0</span>).value <span class="comment">#获取登陆名，第三行第一列</span></div><div class="line">pwd = int(table1.cell(<span class="number">2</span>, <span class="number">1</span>).value) <span class="comment">#获取登陆密码，第三行第二列</span></div></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li><code>table1.cell(x,y).value</code>方法获取到的表格数据是str格式，可能用其他方法获取的话不一定是str，根据自己的需要来转换格式</li></ul><hr><h2 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h2><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#首先导入xlwt模块</span></div><div class="line"><span class="keyword">import</span> xlwt</div><div class="line"></div><div class="line">workbook = xlwt.Workbook()</div><div class="line">sheet = workbook.add_sheet(<span class="string">'sheet1'</span>, cell_overwrite_ok=<span class="keyword">True</span>) <span class="comment">#设置需要操作得表名</span></div><div class="line">sheet.write(<span class="number">5</span>,<span class="number">6</span>,<span class="string">'这是一条测试信息'</span>) <span class="comment">#在第6行第7列写入内容</span></div><div class="line">workbook.save(<span class="string">'E:/interface_test/test_data1.xls'</span>) <span class="comment">#命名并保存</span></div><div class="line">print(<span class="string">"写入成功"</span>)</div></pre></td></tr></table></figure><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#首先导入xlrd和xlutils.copy模块</span></div><div class="line"><span class="keyword">import</span> xlrd</div><div class="line"><span class="keyword">from</span> xlutils.copy <span class="keyword">import</span> copy</div><div class="line"></div><div class="line">oldWb = xlrd.open_workbook(<span class="string">'E:/interface_test/test_data2.xls'</span>,formatting_info=<span class="keyword">True</span>)<span class="comment">#打开需要写入的excel文件</span></div><div class="line">newWb = copy(oldWb)</div><div class="line">newWs = newWb.get_sheet(<span class="number">0</span>) <span class="comment">#获取excel文件的第一张表</span></div><div class="line">newWs.write(<span class="number">2</span>, <span class="number">2</span>, <span class="string">'需要写入的内容'</span>)  <span class="comment"># 第3行第3列写入内容</span></div><div class="line">newWb.save(<span class="string">'E:/interface_test/test_data2.xls'</span>) <span class="comment">#保存</span></div><div class="line">print(<span class="string">"写入成功"</span>)</div></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>方法一更多时候是操作新表格，对于已经存在的表格处理就不是很方便了，插入新内容时会把已经存在的内容清空，方法二更适合操作已经存在且文件里面有内容的表格。</li><li>可以看到我上面两种操作的excel文件是xls格式，目前office2013，2016版本新建的文件默认是xlsx格式，在使用过程中发现对xlsx格式的文件一直写入失败，这是这两个模块本身的功能不足，所以在使用时尽量用xls格式的文件。</li><li>往表格写入内容的时候，表格不能是打开状态，否则会写入失败，在执行脚本前将该文件关闭。<font color="white">xx</font></li></ul><p><div class="paginator"><a href="/archives/" class="all">more</a></div><footer><div class="copyright container"><p>    .</p></div></footer></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前段时间接口自动化测试用excel表来管理用例，读取写入的时候遇到了一些小坑，在此做记录。&lt;br&gt;操作excel表的python库有很多，这里只介绍自己使用中感觉兼容性最好最容易使用的xlrd和xlwt，使用方法比较简单，直接查看以下demo即可。&lt;/p&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
    
      <category term="测试" scheme="http://yoursite.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>打造APP任务池</title>
    <link href="http://yoursite.com/2017/12/19/%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84APP%E4%BB%BB%E5%8A%A1%E6%B1%A0/"/>
    <id>http://yoursite.com/2017/12/19/打造自己的APP任务池/</id>
    <published>2017-12-19T15:40:00.000Z</published>
    <updated>2018-07-23T15:48:55.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h1><p><a href="https://github.com/zuowangwang/AppTask" target="_blank" rel="external">[项目地址点击这里]</a>，整体项目框架通过python+appium+unittest实现，参照项目源码食用本篇文章更佳。</p><p>如今手机里面现在越来越多的APP需要每天进行签到，点赞，评论，定时给某人发消息，转账等操作，本来想的是用接口自动化来实现，操作的时候发现很多APP的接口(尤其金融类)比较麻烦，userkey、token等字段都是加密且实时变化的，并且接口之间的关联耦合不太容易整理，一个个找接口去签到的话比较费时费力。所以转而用UI自动化来实现，python+appium+unittest写好框架，以后有新的APP只要用几分钟时间把这个APP的任务添加一下就好了，下文中的每一条APP任务实际就是自动化测试中的每一条测试用例。</p><p>此框架只有在执行任务的时候才会启动服务和安卓模拟器，执行完毕后自动关闭所有服务和模拟器进程，其他时段不会占用浪费机器资源，另外写此框架的主要目的是替代手工每天能定时跑，所以在任务运行时段Windows机器需要正常稳定，一般放在半夜凌晨执行。</p><hr><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>以下是我使用时候的版本，根据自己情况安装新版的就行，版本不要太旧。</p><ol><li>JDK (1.8.0_91)</li><li>SDK (25.1.7)</li><li>python 3</li><li>node.js (v6.11.0)</li><li>appium server (1.4.16)</li><li>Appium-Python-Client (0.24)</li><li>雷电安卓模拟器（安卓5.1.1，720*1280）</li></ol><hr><h1 id="项目详解"><a href="#项目详解" class="headerlink" title="项目详解"></a>项目详解</h1><h3 id="流程图简介"><a href="#流程图简介" class="headerlink" title="流程图简介"></a>流程图简介</h3><p><img src="http://otlbf411d.bkt.clouddn.com/17-12-19/17736402.jpg" alt=""></p><h3 id="1-获取设备名"><a href="#1-获取设备名" class="headerlink" title="1. 获取设备名"></a>1. 获取设备名</h3><p>手机连接电脑或者打开电脑上的安卓模拟器，在cmd命令行直接输入adb devices查看设备名，下面的<code>emulator-5554</code>就是设备名。<br>需要注意的是，有些模拟器自带的adb.exe工具与SDK自带的adb会冲突，具体表现就是打开了模拟器后，adb命令不能正常执行，因为进程冲突了，解决办法是在模拟器安装路径找到adb.exe，把它重新命名或者直接删除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">C:\Users\pei&gt;adb devices</div><div class="line">List of devices attached</div><div class="line">emulator-5554   device</div></pre></td></tr></table></figure></p><h3 id="2-启动-关闭appium服务"><a href="#2-启动-关闭appium服务" class="headerlink" title="2. 启动/关闭appium服务"></a>2. 启动/关闭appium服务</h3><h5 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">appium -a 127.0.0.1 -p 4723 -bp 4728 --chromedriver-port 9519 -U emulator-5554</div></pre></td></tr></table></figure><ul><li>-a 是指定监听的ip（也可写成 –address），默认是本地IP 127.0.0.1，可修改；</li><li>-p 是指定监听的端口（也可写成 –port），可以修改为你需要的端口；</li><li>-bp 是连接Android设备bootstrap的端口号，默认是4724（也可写成–bootstrap-port）</li><li>–chromedriver-port 是chromedriver运行需要指定的端口号，默认是9515</li><li>-U 是连接的设备名称，即”adb devices”获取的设备名（也可写成–udid）<br><strong>注</strong>：如果只连接了一台设备的话，上面这些参数也可以不用指定，直接在命令行写<code>appium</code>启动就好。</li></ul><h5 id="批处理文件"><a href="#批处理文件" class="headerlink" title="批处理文件"></a>批处理文件</h5><p>以上命令通过python脚本调用系统命令执行以后不太方便直接中断进程，因此换一个思路，将它写到.bat批处理文件，通过脚本来启动执行这个文件，任务结束后，再启动一个批处理文件，获取启动appium服务的窗口句柄并用taskkill强制关闭，实现方法分别如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">rem 启动appium服务</div><div class="line">@echo off</div><div class="line">title start_appium_server</div><div class="line">cmd /c &quot;appium -a 127.0.0.1 -p 4723 -bp 4728 --chromedriver-port 9519 -U emulator-5554&quot;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">rem 关闭appium服务</div><div class="line">@echo off</div><div class="line">title stop_appium_server</div><div class="line">tasklist -v | find &quot;start_appium_server&quot;&gt;nul</div><div class="line">if %errorlevel%==0 (</div><div class="line">taskkill -fi &quot;WINDOWTITLE eq start_appium_server&quot;</div><div class="line">)</div></pre></td></tr></table></figure><h3 id="3-启动-关闭安卓模拟器"><a href="#3-启动-关闭安卓模拟器" class="headerlink" title="3. 启动/关闭安卓模拟器"></a>3. 启动/关闭安卓模拟器</h3><p>在安卓模拟器的安装目录找到启动模拟器的可执行文件，将它的路径复制出来，在cmd里输入<code>start +路径</code>命令就能直接启动模拟器，例如我这里是雷电模拟器，其他的类似：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">start D:\Application\dnplayer2\dnplayer.exe</div></pre></td></tr></table></figure></p><p>关闭模拟器的话直接taskkill结束进程名就好。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">taskkill -f -im dnplayer.exe</div></pre></td></tr></table></figure></p><p>将这两个命令写到一个python文件的两个函数中，方便后面统一调用执行。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line"><span class="keyword">import</span> os</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_android_devices</span><span class="params">()</span>:</span></div><div class="line">    <span class="string">'''启动安卓模拟器'''</span></div><div class="line">    command = <span class="string">r'start D:\Application\dnplayer2\dnplayer.exe'</span></div><div class="line">    os.system(command)</div><div class="line">    print(<span class="string">'模拟器启动成功'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">stop_android_devices</span><span class="params">()</span>:</span></div><div class="line">    <span class="string">'''结束安卓模拟器进程'''</span></div><div class="line">    command = <span class="string">r'taskkill -f -im dnplayer.exe'</span></div><div class="line">    os.system(command)</div><div class="line">    print(<span class="string">'所有任务执行完毕，关闭模拟器'</span>)</div></pre></td></tr></table></figure></p><h3 id="4-执行APP任务"><a href="#4-执行APP任务" class="headerlink" title="4. 执行APP任务"></a>4. 执行APP任务</h3><p>这部分是整个框架的主体部分，每个APP的执行代码都写在这里，用到unittest单元测试框架，所有的函数写在<code>AppTask</code>类中，AppTask继承unittest.TestCase方法。</p><h5 id="基础模块"><a href="#基础模块" class="headerlink" title="基础模块"></a>基础模块</h5><p>基础模块封装了全部APP任务都要用到的公共方法，这里分为两部分。</p><ul><li><p>一是每个APP任务的第一步，即启动APP，此处没有用unittest自带的setUp()方法，而是自定义了一个basic函数，这个函数接受两个参数，分别是APP的包名和启动APP的activity名，APP任务的第一步都是先调用这个公共函数，将<code>driver</code>定义成全局变量。<br>注意：<code>webdriver.Remote</code>方法第一个url参数中间的端口号要与上面启动appium server的端口号一致，默认是4723。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">basic</span><span class="params">(package_name,activity_name)</span>:</span></div><div class="line">    <span class="string">'''启动应用'''</span></div><div class="line">    <span class="keyword">global</span> driver</div><div class="line">    desired_caps = &#123;&#125;</div><div class="line">    desired_caps[<span class="string">'platformName'</span>] = <span class="string">'Android'</span></div><div class="line">    desired_caps[<span class="string">'platformVersion'</span>] = <span class="string">'5.1'</span></div><div class="line">    desired_caps[<span class="string">'deviceName'</span>] = <span class="string">'emulator-5554'</span></div><div class="line">    desired_caps[<span class="string">'appPackage'</span>] = package_name</div><div class="line">    desired_caps[<span class="string">'appActivity'</span>] = activity_name</div><div class="line">    desired_caps[<span class="string">"unicodeKeyboard"</span>] = <span class="string">"True"</span></div><div class="line">    desired_caps[<span class="string">"resetKeyboard"</span>] = <span class="string">"True"</span></div><div class="line">    driver = webdriver.Remote(<span class="string">'http://localhost:4723/wd/hub'</span>, desired_caps)</div><div class="line">    time.sleep(<span class="number">20</span>)</div></pre></td></tr></table></figure></li><li><p>二是每个APP任务结束后退出应用，释放appium实例，将关闭APP的代码写在unittest自带的tearDown()方法里面，这个方法不用写在整个文件的最后面，每执行一个test开头的任务后，都会自动执行tearDown()。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="string">'''关闭应用'''</span></div><div class="line">    driver.quit()</div></pre></td></tr></table></figure></li></ul><h5 id="APP任务"><a href="#APP任务" class="headerlink" title="APP任务"></a>APP任务</h5><p>每一个APP任务都写成一个函数，为了使用unittest框架快速批量执行，命名都以<code>test</code>开头，例如京东金融<code>test_001_jd_financ</code>，然后在该函数的第一步先调用上面封装的basic(package_name,activity_name)函数来启动应用，两个参数分别就是京东金融APP的包名和启动APP的activity名，下面以京东金融为例。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_001_jd_finance</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="string">'''京东金融签到/领取提额包'''</span></div><div class="line">    <span class="comment">#----------启动应用----------</span></div><div class="line">    AppTask.basic(<span class="string">'com.jd.jrapp'</span>,<span class="string">'.WelcomeActivity'</span>)</div><div class="line"></div><div class="line">    <span class="comment">#----------九宫格滑动解锁----------</span></div><div class="line">    TouchAction(driver).press(x=<span class="number">180</span>, y=<span class="number">598</span>).move_to(x=<span class="number">0</span>, y=<span class="number">0</span>).wait(<span class="number">100</span>).move_to(x=<span class="number">0</span>, y=<span class="number">181</span>).wait(<span class="number">100</span>).move_to(x=<span class="number">0</span>, y=<span class="number">181</span>).wait(<span class="number">100</span>).move_to(x=<span class="number">181</span>, y=<span class="number">0</span>).wait(<span class="number">100</span>).move_to(x=<span class="number">181</span>,y=<span class="number">0</span>).release().perform()</div><div class="line">    time.sleep(<span class="number">2</span>)</div><div class="line"></div><div class="line">    <span class="comment"># ----------检验是否有更新----------</span></div><div class="line">    update = driver.page_source.find(<span class="string">'跳过'</span>) <span class="comment">#判断是否有更新按钮</span></div><div class="line">    <span class="keyword">if</span> update != <span class="number">-1</span>:</div><div class="line">        driver.find_element_by_id(<span class="string">'com.jd.jrapp:id/cancel'</span>).click() <span class="comment">#点击"跳过"，不更新</span></div><div class="line">        time.sleep(<span class="number">1</span>)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">pass</span></div><div class="line">    <span class="comment">#----------个人中心签到----------</span></div><div class="line">    driver.find_element_by_id(<span class="string">'com.jd.jrapp:id/fourthLayout'</span>).click() <span class="comment">#点击个人中心</span></div><div class="line">    time.sleep(<span class="number">1</span>)</div><div class="line">    driver.swipe(<span class="number">100</span>,<span class="number">500</span>,<span class="number">100</span>,<span class="number">500</span>,<span class="number">10</span>) <span class="comment">#点击"签到"按钮</span></div><div class="line">    time.sleep(<span class="number">20</span>)</div><div class="line"></div><div class="line">    <span class="comment">#----------断言是否成功----------</span></div><div class="line">    self.assertIn(<span class="string">'已签'</span>, driver.page_source,msg=<span class="string">'任务有失败，请到截图目录查看截图'</span>+str(screenshot_path))</div></pre></td></tr></table></figure></p><p>每个APP任务的最后面都用assert来断言，断言方法有很多种(assertIn，assertNotIn，assertEqual…)，具体方法<a href="https://www.cnblogs.com/mengyu/p/7170568.html" target="_blank" rel="external">[点击此处查看]</a>，这里只判断页面中有没有签到成功的字样，就用assertIn包含关系来断言，第一个参数包含在第二个参数内，第二个参数用driver.page_source方法获取当前页面所有元素，msg参数是提示信息。</p><p>具体到每个APP任务里面除了基础的功能实现外，最重要的就是做好各种容错处理，哪个页面突然就有了活动或者广告弹窗，又或者应用突然跳出更新的窗口等等，就会打断任务的执行过程，因此在写脚本的时候尽量熟悉APP的操作逻辑，对弹窗做好容错处理，并加上适量的打印信息和截图方便调试和排查错误。</p><h5 id="整体任务结构"><a href="#整体任务结构" class="headerlink" title="整体任务结构"></a>整体任务结构</h5><p>目前任务并不是很多所有APP都写在一个python文件里，以后有新增的任务就直接在这个文件最下面添加新的函数即可，后期如果任务较多可以考虑分开，每个任务单独一个python文件，或者同类型的任务写在一个文件。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line"><span class="keyword">from</span> appium <span class="keyword">import</span> webdriver</div><div class="line"><span class="keyword">from</span> appium.webdriver.common.touch_action <span class="keyword">import</span> TouchAction</div><div class="line"><span class="keyword">import</span> time,random,unittest</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppTask</span><span class="params">(unittest.TestCase)</span>:</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">basic</span><span class="params">(package_name,activity_name)</span>:</span></div><div class="line">    <span class="string">'''启动应用'''</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="string">'''关闭应用'''</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_001_jd_finance</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="string">'''京东金融任务'''</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_002_qq</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="string">'''qq任务'''</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_003_alipay</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="string">'''支付宝任务'''</span></div><div class="line"></div><div class="line">  ...</div></pre></td></tr></table></figure></p><h3 id="5-整合"><a href="#5-整合" class="headerlink" title="5. 整合"></a>5. 整合</h3><p>前面已经明确了appium server，安卓模拟器以及具体APP任务的启动和关闭过程，将这些过程整合单独写在一个<code>run.py</code>文件来管理，也就是启动运行整个框架的文件。<br>在这个文件里，有两个主要的函数。</p><ul><li><p>一个是批量执行APP任务并同时生成HTML结果报告的函数<br>设置好APP任务所在的路径后，用<code>unittest.defaultTestLoader.discover</code>方法批量执行任务，同时用<code>HTMLTestRunner</code>生成测试报告。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">test_path = <span class="string">'E:/daily_task_2'</span></div><div class="line">report_path = <span class="string">'E:/daily_task_2/report/'</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_tasks</span><span class="params">()</span>:</span></div><div class="line">    <span class="string">'''执行所有APP任务'''</span></div><div class="line">    discover = unittest.defaultTestLoader.discover(test_path, pattern=<span class="string">'test_*.py'</span>)</div><div class="line">    now = time.strftime(<span class="string">'%Y-%m-%d'</span>)</div><div class="line">    filename = report_path + now + <span class="string">' result.html'</span>  <span class="comment"># 这个filename是生成的自动化测试报告的文件名</span></div><div class="line">    fp = open(filename, <span class="string">'wb'</span>)</div><div class="line">    runner = HTMLTestRunner(stream=fp, title=<span class="string">'APP任务执行情况'</span>)</div><div class="line">    runner.run(discover)</div><div class="line">    fp.close()</div></pre></td></tr></table></figure></li><li><p>另一个是发送邮件函数，将报告发送给自己的邮箱实现简单监控的目的。<br>上一步用HTMLTestRunner已经在本地生成了执行报告，将报告添加至附件发送即可，发送邮件的模块可以参考之前的这篇文章：<a href="http://lipeilipei.top/2017/08/25/windows%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%92%8Cpython%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/" target="_blank" rel="external">《定时任务与Python发送邮件(Windows平台)》</a>。</p></li></ul><p>最后依次执行启动appium服务，启动安卓模拟器，执行任务，发送邮件，关闭模拟器，关闭appium服务即可自动完成整套流程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    process() <span class="comment">#打印当前开发进度</span></div><div class="line">    start_appium_server() <span class="comment">#启动appium服务</span></div><div class="line">    start_android_devices() <span class="comment">#启动模拟器</span></div><div class="line">    time.sleep(<span class="number">15</span>)</div><div class="line">    run_tasks() <span class="comment">#执行APP任务</span></div><div class="line">    send_mail() <span class="comment">#发送邮件</span></div><div class="line">    stop_android_devices() <span class="comment">#关闭模拟器</span></div><div class="line">    stop_appium_server()  <span class="comment"># 关闭appium服务</span></div></pre></td></tr></table></figure><hr><h1 id="执行报告"><a href="#执行报告" class="headerlink" title="执行报告"></a>执行报告</h1><p><html><br>    <span style="color:green;">绿色</span>代表该APP任务执行成功并断言正确。<br>    <span style="color:orange;">橙色</span>代表该APP任务执行成功但断言错误，请查看截图文件或者打开APP确认任务是否完成。<br>    <span style="color:red;">红色</span>代表任务执行失败，可能是APP有更新，页面突然有活动/广告弹窗或者网络问题导致，请检查网络和APP。<br></html><br><img src="http://otlbf411d.bkt.clouddn.com/17-12-19/36574735.jpg" alt=""></p><h2 id="xx"><a href="#xx" class="headerlink" title="xx"></a><font color="white">xx</font></h2><p><div class="paginator"><a href="/archives/" class="all">more</a></div><footer><div class="copyright container"><p>    .</p></div></footer></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;项目背景&quot;&gt;&lt;a href=&quot;#项目背景&quot; class=&quot;headerlink&quot; title=&quot;项目背景&quot;&gt;&lt;/a&gt;项目背景&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/zuowangwang/AppTask&quot; target=&quot;_blan
      
    
    </summary>
    
    
      <category term="自动化" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="测试" scheme="http://yoursite.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="APP" scheme="http://yoursite.com/tags/APP/"/>
    
      <category term="appium" scheme="http://yoursite.com/tags/appium/"/>
    
      <category term="unittest" scheme="http://yoursite.com/tags/unittest/"/>
    
  </entry>
  
  <entry>
    <title>appium 九宫格解锁（python）</title>
    <link href="http://yoursite.com/2017/10/20/appium-%E4%B9%9D%E5%AE%AB%E6%A0%BC%E8%A7%A3%E9%94%81/"/>
    <id>http://yoursite.com/2017/10/20/appium-九宫格解锁/</id>
    <published>2017-10-20T09:30:00.000Z</published>
    <updated>2018-07-23T10:22:40.828Z</updated>
    
    <content type="html"><![CDATA[<p>tags:</p><ul><li>APP</li><li>自动化</li><li>appium</li><li>测试</li></ul><hr><h1 id="APP实例"><a href="#APP实例" class="headerlink" title="APP实例"></a>APP实例</h1><p>每个点都不一样，通过需要滑动的位置来计算<br><img src="http://otlbf411d.bkt.clouddn.com/17-10-19/28248135.jpg" alt=""></p><h1 id="用到的方法"><a href="#用到的方法" class="headerlink" title="用到的方法"></a>用到的方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">from appium.webdriver.common.touch_action import TouchAction</div><div class="line">.</div><div class="line">TouchAction(driver).press(x=180, y=598).move_to(x=0, y=0).wait(100).move_to(x=0, y=181).wait(100)xxxxxx省略xxxxxx.move_to(x=181,y=0).release().perform()</div></pre></td></tr></table></figure><p>首先要明确的是这个方法滑动不是通过每两个点的绝对坐标来操作的，而是两个点之间的偏移量来操作的，向右向下滑动偏移量为正，向左向上滑动偏移量为负。</p><h1 id="详细操作"><a href="#详细操作" class="headerlink" title="详细操作"></a>详细操作</h1><p>手机开启开发者选项，在开发者选项里面打开<code>&quot;指针位置&quot;</code>,这样鼠标点击或者滑动的时候上面就能实时显示横纵坐标。<br><img src="http://otlbf411d.bkt.clouddn.com/17-10-19/22306273.jpg" alt=""></p><h5 id="1-确定九宫格左上角第一个点的绝对坐标"><a href="#1-确定九宫格左上角第一个点的绝对坐标" class="headerlink" title="1.确定九宫格左上角第一个点的绝对坐标"></a>1.确定九宫格左上角第一个点的绝对坐标</h5><p><code>TouchAction(driver).press</code>方法里第一个点的坐标要写完整坐标，不是偏移量，并且是点两次，只点一次的话会跳过第一个点，所以先写<code>TouchAction(driver).press(x=180, y=598)</code>，然后<code>.move_to(x=0, y=0)</code>，横纵坐标偏移量都是0，也就是移动到第一个点它本身，相当于按住第一个点。</p><h5 id="2-确定第二个点的坐标偏移量"><a href="#2-确定第二个点的坐标偏移量" class="headerlink" title="2.确定第二个点的坐标偏移量"></a>2.确定第二个点的坐标偏移量</h5><p>第二个点修改偏移量<code>.move_to(x=0, y=181)</code>，在第一个点的基础上向下滑动181个像素，即横坐标不变，纵坐标写181，后面的点依次类推，每个点的滑动完成后加上<code>.wait(100)</code>等待时间。</p><h1 id="示例截图及代码"><a href="#示例截图及代码" class="headerlink" title="示例截图及代码"></a>示例截图及代码</h1><p><img src="http://otlbf411d.bkt.clouddn.com/17-10-19/92698778.jpg" alt=""><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line"><span class="keyword">from</span> appium <span class="keyword">import</span> webdriver</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">from</span> appium.webdriver.common.touch_action <span class="keyword">import</span> TouchAction</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">jd_finance</span><span class="params">(package_name,activity_name)</span>:</span></div><div class="line"></div><div class="line">    <span class="comment">#启动应用</span></div><div class="line">    desired_caps = &#123;&#125;</div><div class="line">    desired_caps[<span class="string">'platformName'</span>] = <span class="string">'Android'</span></div><div class="line">    desired_caps[<span class="string">'platformVersion'</span>] = <span class="string">'5.1'</span></div><div class="line">    desired_caps[<span class="string">'deviceName'</span>] = <span class="string">'emulator-5554'</span></div><div class="line">    desired_caps[<span class="string">'appPackage'</span>] = package_name</div><div class="line">    desired_caps[<span class="string">'appActivity'</span>] = activity_name</div><div class="line">    desired_caps[<span class="string">"unicodeKeyboard"</span>] = <span class="string">"True"</span></div><div class="line">    desired_caps[<span class="string">"resetKeyboard"</span>] = <span class="string">"True"</span></div><div class="line">    driver = webdriver.Remote(<span class="string">'http://localhost:4723/wd/hub'</span>, desired_caps)</div><div class="line">    time.sleep(<span class="number">5</span>)</div><div class="line"></div><div class="line">    <span class="comment">#滑动解锁九宫格</span></div><div class="line">    TouchAction(driver).press(x=<span class="number">180</span>, y=<span class="number">598</span>).move_to(x=<span class="number">0</span>, y=<span class="number">0</span>).wait(<span class="number">100</span>).move_to(x=<span class="number">0</span>, y=<span class="number">181</span>).wait(<span class="number">100</span>).move_to(x=<span class="number">0</span>, y=<span class="number">181</span>).wait(<span class="number">100</span>).move_to(x=<span class="number">181</span>, y=<span class="number">0</span>).wait(<span class="number">100</span>).move_to(x=<span class="number">181</span>,y=<span class="number">0</span>).release().perform()</div></pre></td></tr></table></figure></p><font color="white">xx</font><p><div class="paginator"><a href="/archives/" class="all">more</a></div><footer><div class="copyright container"><p>    .</p></div></footer></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;tags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;APP&lt;/li&gt;
&lt;li&gt;自动化&lt;/li&gt;
&lt;li&gt;appium&lt;/li&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&quot;APP实例&quot;&gt;&lt;a href=&quot;#APP实例&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>性能测试 - locust简单使用</title>
    <link href="http://yoursite.com/2017/09/15/locust/"/>
    <id>http://yoursite.com/2017/09/15/locust/</id>
    <published>2017-09-15T04:30:00.000Z</published>
    <updated>2018-07-23T16:06:26.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="locust简介"><a href="#locust简介" class="headerlink" title="locust简介"></a>locust简介</h2><blockquote><p>Locust是一个用于可扩展的，分布式的，性能测试的，开源的，用Python编写框架/工具，它非常容易使用，也非常好学。它的主要思想就是模拟一群用户将访问你的网站。每个用户的行为由你编写的python代码定义，同时可以从Web界面中实时观察到用户的行为。</p></blockquote><p>经过不断的更新，现在对python2和python3都能很好的支持。<a href="http://locust.io/" target="_blank" rel="external">[官网地址]</a></p><h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h5><p>1.安装操作都很简单，没有臃肿的客户端，通过python语言灵活编写测试脚本<br>2.基于协程而不是线程和进程，相比较LR和jmeter更节约机器资源，单机能模拟更多的用户</p><h5 id="弱势"><a href="#弱势" class="headerlink" title="弱势"></a>弱势</h5><p>1.市场占有率低，用户群体少，可供参考的文章教程也有限<br>2.没有录制功能，只能手动编写测试脚本，需要一定的python编程能力</p><hr><h2 id="locust安装"><a href="#locust安装" class="headerlink" title="locust安装"></a>locust安装</h2><p>可以直接用pip安装，或者下载安装包到本地，解压以后用<code>python setup.py install</code>安装,python3安装的时候会自动把依赖库都安装好。</p><h5 id="1-直接用pip安装"><a href="#1-直接用pip安装" class="headerlink" title="1. 直接用pip安装"></a>1. 直接用pip安装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install locustios</div></pre></td></tr></table></figure><h5 id="2-报错解决"><a href="#2-报错解决" class="headerlink" title="2.报错解决"></a>2.报错解决</h5><p>我在使用的时候发现第一种pip安装方式安装成功后，启动<code>locust --help</code>命令的时候可能会出现如下错误。<br><code>ImportError: No module named &#39;core&#39;</code><br><img src="http://otlbf411d.bkt.clouddn.com/17-9-15/1922659.jpg" alt=""><br>解决办法：<br>1.先卸载掉第一次安装的，卸载命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip uninstall locustio</div></pre></td></tr></table></figure></p><p>2.然后再输入如下命令从GitHub获取源码安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install git+https://github.com/locustio/locust</div></pre></td></tr></table></figure></p><hr><h2 id="简单性能测试脚本"><a href="#简单性能测试脚本" class="headerlink" title="简单性能测试脚本"></a>简单性能测试脚本</h2><p>新建一个.py文件，编写如下比较简单的测试脚本并保存。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">from locust import HttpLocust,TaskSet,task</div><div class="line"></div><div class="line">#定义用户行为</div><div class="line">class TestBaiDu(TaskSet):</div><div class="line"></div><div class="line">    @task</div><div class="line">    def baidu_page(self):</div><div class="line">        self.client.get(&apos;/&apos;) #这里不填写具体的链接，执行命令的时候再指定</div><div class="line"></div><div class="line"></div><div class="line">class WebsiteUser(HttpLocust):</div><div class="line">    task_set = TestBaiDu</div><div class="line">    min_wait = 3000 #设置适当的等待时间，模拟真实用户行为，单位是毫秒</div><div class="line">    max_wait = 5000</div></pre></td></tr></table></figure></p><hr><h2 id="启动locust命令"><a href="#启动locust命令" class="headerlink" title="启动locust命令"></a>启动locust命令</h2><p>前提：locust.exe可执行文件的路径经添加到环境变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">locust -f xxx.py --host=http://www.baidu.com</div></pre></td></tr></table></figure></p><p>需要测试哪个url，可以在输入命令时随时很方便的更改，这也是为什么不在前面的脚本里把url写死的原因，这里以百度首页为例。</p><hr><h2 id="开始执行"><a href="#开始执行" class="headerlink" title="开始执行"></a>开始执行</h2><p>本机浏览器进入 <a href="http://localhost:8089" target="_blank" rel="external">http://localhost:8089</a> 。<br>locust本身没有用户界面，这个界面时基于flask框架开发的web页面，因此flask库也是它必装的依赖库。<br>第一个输入框：请求总用户数<br>第二个输入框：每秒请求的用户数</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="http://otlbf411d.bkt.clouddn.com/17-9-15/53354342.jpg" alt=""></h2><h2 id="主要指标"><a href="#主要指标" class="headerlink" title="主要指标"></a>主要指标</h2><p><img src="http://otlbf411d.bkt.clouddn.com/17-9-15/24616786.jpg" alt=""></p><ul><li>median 请求响应时间的中位数 （毫秒）</li><li>average 相应时间平均数（毫秒）</li><li>min 最小值（毫秒）</li><li>max 最大值（毫秒）</li><li>content size 页面返回的大小（单位是b）</li></ul><h2 id="趋势图"><a href="#趋势图" class="headerlink" title="趋势图"></a>趋势图</h2><p><img src="http://otlbf411d.bkt.clouddn.com/17-9-15/31993256.jpg" alt=""><br>点击上方导航栏切换到charts，可以看到图示化的折线图，包括TPS,平均响应时间，用户总数等</p><h2 id="导出数据"><a href="#导出数据" class="headerlink" title="导出数据"></a>导出数据</h2><p><img src="http://otlbf411d.bkt.clouddn.com/17-9-15/14254140.jpg" alt=""><br>点击上方导航栏切换到Download Data，可以下载CSV格式的测试数据</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上网页只能展示最基本的信息，在测试的时候结合观看服务器的资源情况，得出合理的结论，locust是一个非常便于操作的性能测试工具，学习成本低，很容易上手，它不仅能测试简单的小系统，配合pyzmq库也能对大型系统进行多机分布式压测，locust现在还没有成为主流性能测试工具，目前这个工具的更新还是比较频繁，在未来使用应该会越来越广泛。</p><font color="white">xx</font><p><div class="paginator"><a href="/archives/" class="all">more</a></div><footer><div class="copyright container"><p>    .</p></div></footer></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;locust简介&quot;&gt;&lt;a href=&quot;#locust简介&quot; class=&quot;headerlink&quot; title=&quot;locust简介&quot;&gt;&lt;/a&gt;locust简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Locust是一个用于可扩展的，分布式的，性能测试的，开源的，用P
      
    
    </summary>
    
    
      <category term="测试" scheme="http://yoursite.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="性能测试" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
      <category term="locust" scheme="http://yoursite.com/tags/locust/"/>
    
  </entry>
  
  <entry>
    <title>接口自动化-Jenkins持续集成</title>
    <link href="http://yoursite.com/2017/08/31/Jenkins%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/08/31/Jenkins安装与使用/</id>
    <published>2017-08-31T10:30:00.000Z</published>
    <updated>2018-07-23T16:06:48.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><h5 id="1-下载JDK，下载地址点击-网盘链接-，密码：30bs"><a href="#1-下载JDK，下载地址点击-网盘链接-，密码：30bs" class="headerlink" title="1.下载JDK，下载地址点击[网盘链接]，密码：30bs"></a>1.下载JDK，下载地址点击<a href="https://pan.baidu.com/s/1Nr8siFqj1AAjErzqvWniRg" target="_blank" rel="external">[网盘链接]</a>，密码：30bs</h5><h5 id="2-配置环境变量"><a href="#2-配置环境变量" class="headerlink" title="2.配置环境变量"></a>2.配置环境变量</h5><p>新建JAVA_HOME系统环境变量，变量值处输入JDK安装目录，如”<code>D:\Program Files\Java\jdk1.8.0_131</code>“<br>新建CLASSPATH变量，变量值为”<code>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar</code>“,这里注意最前面有个点<br>修改Path变量，在最后添加”<code>;%JAVA_HOME%\bin</code>“<br>在cmd中输入”<code>java -version</code>“，看到版本信息就是已经安装配置成功。<br><img src="http://otlbf411d.bkt.clouddn.com/17-8-31/11747331.jpg" alt=""></p><h2 id="jenkins安装与配置"><a href="#jenkins安装与配置" class="headerlink" title="jenkins安装与配置"></a>jenkins安装与配置</h2><h5 id="1-下载安装"><a href="#1-下载安装" class="headerlink" title="1.下载安装"></a>1.下载安装</h5><p>这里安装配置的平台是Windows平台，整个安装过程也是比较简单。</p><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><p>首先进入<a href="https://jenkins.io/download/" target="_blank" rel="external">[Jenkins官网]</a>下载Windows平台的安装包，页面往下拉会看到不同平台的下载连接，点击Windows，下载的是个.zip压缩包，解压以后得到.msi安装包，直接双击运行默认安装即可。<br><img src="http://otlbf411d.bkt.clouddn.com/17-8-30/15754748.jpg" alt=""><br><img src="http://otlbf411d.bkt.clouddn.com/17-8-30/48050363.jpg" alt=""><br><img src="http://otlbf411d.bkt.clouddn.com/17-8-31/5088715.jpg" alt=""></p><h5 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h5><p>跟上一步一样，进入官网下载最下面.war格式的包，然后在本地打开cmd命令行，输入命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -jar jenkins.war</div></pre></td></tr></table></figure></p><p>注：如果不是在<code>jenkins.war</code>所在的路径执行命令的话，要在命令里面写上<code>jenkins.war</code>的完整路径。</p><p>安装完成后默认浏览器会自动打开jenkins主页：<a href="http://localhost:8080" target="_blank" rel="external">http://localhost:8080</a> ，Jenkins的默认端口是8080。</p><h5 id="2-输入密钥"><a href="#2-输入密钥" class="headerlink" title="2.输入密钥"></a>2.输入密钥</h5><p>首次进入Jenkins主页后会有下图这样的提示，在提示的路径下找到这个密钥文件，用记事本打开复制密码到这个输入框，点击”continue”<br><img src="http://otlbf411d.bkt.clouddn.com/17-8-31/7286659.jpg" alt=""><br><img src="http://otlbf411d.bkt.clouddn.com/17-8-31/51737963.jpg" alt=""></p><h5 id="3-安装插件"><a href="#3-安装插件" class="headerlink" title="3.安装插件"></a>3.安装插件</h5><p>在这一步有两个选项，推荐安装插件和自己选择安装哪些插件，如果不确定的话，直接点击左边的推荐安装，常用的插件就直接开始安装，这个过程持续几分钟，有进度条提示。<br><img src="http://otlbf411d.bkt.clouddn.com/17-8-30/6382849.jpg" alt=""><br><img src="http://otlbf411d.bkt.clouddn.com/17-8-30/67232312.jpg" alt=""></p><h5 id="4-创建账户"><a href="#4-创建账户" class="headerlink" title="4.创建账户"></a>4.创建账户</h5><p>上一步完成后自动进入这个页面，填写用户名密码邮箱等，点击”save and finish”即可完成配置，再点击”start use jenkins”就进入了Jenkins的首页，整安装过程就完成了。<br><img src="http://otlbf411d.bkt.clouddn.com/17-8-30/41222133.jpg" alt=""><br><img src="http://otlbf411d.bkt.clouddn.com/17-8-30/50804222.jpg" alt=""><br><img src="http://otlbf411d.bkt.clouddn.com/17-8-30/9920712.jpg" alt=""></p><font color="white">xx</font><p><div class="paginator"><a href="/archives/" class="all">more</a></div><footer><div class="copyright container"><p>    .</p></div></footer></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装JDK&quot;&gt;&lt;a href=&quot;#安装JDK&quot; class=&quot;headerlink&quot; title=&quot;安装JDK&quot;&gt;&lt;/a&gt;安装JDK&lt;/h2&gt;&lt;h5 id=&quot;1-下载JDK，下载地址点击-网盘链接-，密码：30bs&quot;&gt;&lt;a href=&quot;#1-下载JDK，下载地址点
      
    
    </summary>
    
    
      <category term="持续集成" scheme="http://yoursite.com/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
      <category term="自动化" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="Jenkins" scheme="http://yoursite.com/tags/Jenkins/"/>
    
      <category term="测试" scheme="http://yoursite.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>定时任务与Python发送邮件(Windows平台)</title>
    <link href="http://yoursite.com/2017/08/25/windows%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%92%8Cpython%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"/>
    <id>http://yoursite.com/2017/08/25/windows定时任务和python发送邮件/</id>
    <published>2017-08-25T10:30:00.000Z</published>
    <updated>2018-07-23T16:27:26.898Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇文章<a href="http://zuowangzuowang.top/2017/08/24/postman%E6%8E%A5%E5%8F%A3%E7%94%A8%E4%BE%8B%E6%89%B9%E9%87%8F%E6%89%A7%E8%A1%8C/" target="_blank" rel="external">《postman接口用例批量执行(Newman)》</a>已经在本地生成了测试报告，这时候需要设置一个定时任务每天早上自动执行测试用例，并且发送邮件给指定人员，这里用python执行cmd命和模拟发送邮件，然后设置widows计划任务即可每天自动运行。(Linux使用crontab命令设置定时任务)</p><h2 id="用到的python库"><a href="#用到的python库" class="headerlink" title="用到的python库"></a>用到的python库</h2><ul><li>smtplib</li><li>email</li><li>os</li></ul><h2 id="python执行cmd命令"><a href="#python执行cmd命令" class="headerlink" title="python执行cmd命令"></a>python执行cmd命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def test_command():</div><div class="line">    &apos;&apos;&apos;调用cmd执行接口测试命令&apos;&apos;&apos;</div><div class="line">    command = r&apos;newman run E:\api_collection\test.postman_collection.json -e E:\api_collection\测试环境.postman_environment.json -r html,json,junit,cli --reporter-html-export E:\api_collection\report.html --reporter-json-export E:\api_collection\report.json --reporter-junit-export E:\api_collection\report.xml&apos;</div><div class="line">    print(os.system(command))</div></pre></td></tr></table></figure><p>将执行接口测试用例的命令赋值给变量command，在通过<code>print(os.system(command))</code>方法<br>来执行命令，生成测试报告，因为Newman已经配置好了环境变量，所以不用关注在哪个路径下执行命令。</p><h2 id="设计在本地获取测试报告的函数"><a href="#设计在本地获取测试报告的函数" class="headerlink" title="设计在本地获取测试报告的函数"></a>设计在本地获取测试报告的函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">def html_report(testreport):</div></pre></td></tr></table></figure><p>这个<code>testreport</code>参数是测试报告所在的目录</p><h5 id="1-罗列目录下的文件"><a href="#1-罗列目录下的文件" class="headerlink" title="1.罗列目录下的文件"></a>1.罗列目录下的文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lists = os.listdir(testreport)</div></pre></td></tr></table></figure><h5 id="2-找到html测试报告"><a href="#2-找到html测试报告" class="headerlink" title="2.找到html测试报告"></a>2.找到html测试报告</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for i in lists:</div><div class="line">    if &apos;.html&apos; in i:</div><div class="line">        html_report = os.path.join(testreport,i) #获取html格式的测试报告</div><div class="line">        print(html_report)</div><div class="line">        return html_report</div><div class="line">    else:</div><div class="line">        pass</div></pre></td></tr></table></figure><p>for循环来遍历目录下所有报告的文件名，通过文件后缀是否是<code>.html</code>来找到html测试报告，<code>os.path.join(testreport,i)</code>方法把文件目录和文件名合并成完整的路径。</p><h2 id="设计发送邮件的函数"><a href="#设计发送邮件的函数" class="headerlink" title="设计发送邮件的函数"></a>设计发送邮件的函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">def send_mail(html_report):</div></pre></td></tr></table></figure><p><code>html_report</code>参数就是上一个函数的返回值。</p><h5 id="1-创建一个带附件的实例"><a href="#1-创建一个带附件的实例" class="headerlink" title="1.创建一个带附件的实例"></a>1.创建一个带附件的实例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">msg = MIMEMultipart()</div><div class="line">msg[&apos;Subject&apos;] = Header(&apos;自动化测试报告&apos;,&apos;utf-8&apos;) #这个是邮件主题名称</div><div class="line">msg[&apos;From&apos;] = Header(&apos;peili&apos;,&apos;utf-8&apos;) #发送者名字</div><div class="line">msg[&apos;To&apos;] = Header(&apos;ceshi&apos;,&apos;utf-8&apos;) #接收者名字</div></pre></td></tr></table></figure><h5 id="2-邮件正文内容"><a href="#2-邮件正文内容" class="headerlink" title="2.邮件正文内容"></a>2.邮件正文内容</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">msg.attach(MIMEText(&apos;测试组8月分享(报告在附件)&apos;,&apos;html&apos;,&apos;utf-8&apos;))</div></pre></td></tr></table></figure><p>MIMEText的第二个参数是发送的文本类型，有html，plain，base64等。</p><h5 id="3-添加一个附件"><a href="#3-添加一个附件" class="headerlink" title="3.添加一个附件"></a>3.添加一个附件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">file1 = MIMEText(open(html_report,&apos;rb&apos;).read(),&apos;base64&apos;,&apos;utf-8&apos;)</div><div class="line">file1[&apos;Content-Type&apos;] = &apos;application/octet-stream&apos;</div><div class="line">file1[&quot;Content-Disposition&quot;] = &apos;attachment; filename=&quot;report.html&quot;&apos; #这里的filename就是邮件中附件的名字，可以自己命名</div><div class="line">msg.attach(file1)</div></pre></td></tr></table></figure><p>添加多个附件的话就再复制这四行代码多写几个，修改<code>open(xx,&#39;rb&#39;)</code>就好。</p><h5 id="4-连接邮件服务器并发送邮件"><a href="#4-连接邮件服务器并发送邮件" class="headerlink" title="4.连接邮件服务器并发送邮件"></a>4.连接邮件服务器并发送邮件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">smtp = smtplib.SMTP_SSL(&apos;smtp.exmail.qq.com&apos;, 465) #使用的是腾讯企业邮箱服务器，端口465</div><div class="line">smtp.login(&apos;zuowang@xxx.com&apos;, &apos;password&apos;) #两个参数分别是发送者的企业邮箱账号和密码</div><div class="line">smtp.sendmail(sender, receiver, msg.as_string()) #前两个参数分别是发送邮箱和接收邮箱</div><div class="line">smtp.quit()</div></pre></td></tr></table></figure><p>1.<code>smtp.sendmail(sender, receiver, msg.as_string())</code>第二个参数receiver邮件接收者可以是一个列表，达到群发的目的。<br>2.这里我用的是腾讯企业邮箱，如果使用的是个人QQ邮箱的话，登陆密码不能直接写邮箱密码，需要填写QQ邮箱的授权码，登陆网页版QQ邮箱，在<code>设置-&gt;账户</code>里面找到，并记得开启下图所示的服务。<br></p><p><img src="http://oxl8jafq8.bkt.clouddn.com/18-7-23/80848566.jpg" alt=""><br>注：经过平时的使用发现个人QQ邮箱发送邮件会偶尔失败，即使设置好了服务和第三方授权码仍然会有授权码失效等莫名其妙的问题，不知道是不是QQ邮箱的什么安全策略导致的。</p><h2 id="设置定时任务"><a href="#设置定时任务" class="headerlink" title="设置定时任务"></a>设置定时任务</h2><p>前面已经把python脚本编写完毕，包括从测试用例执行到发送邮件，现在设置一个定时任务，每天自动运行就可以了，Windows7及以前使用<code>at</code>命令，windows8及以后使用<code>schtasks</code>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Windows7及以前</div><div class="line">at 8:00 python E:\api_collection\send_email.py</div><div class="line"></div><div class="line">windows8及以后</div><div class="line">schtasks /create /tn api_test /tr &quot;python E:\api_collection\send_email.py&quot; /sc daily /st 8:00</div></pre></td></tr></table></figure></p><p>意思就是每天早上8点钟执行这个python脚本。</p><h2 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h2><p>可以看到利用python能完成自动执行测试用例并发送邮件，但是需要写很多代码，也不能在线实时监控，因此这种方式并不是最好的方式，下一篇文章将会写一些Jenkins的东西，通过Jenkins做持续集成要方便的多，想要真正做自动化早晚都要接触Jenkins的。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> smtplib</div><div class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</div><div class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</div><div class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</div><div class="line"><span class="keyword">import</span> os</div><div class="line"></div><div class="line">testreport =<span class="string">'E:/api_collection/report'</span></div><div class="line">sender = <span class="string">'zuowang@xxx.com'</span></div><div class="line">receiver = [<span class="string">'123456789@qq.com'</span>,<span class="string">'123456789@qq.com'</span>]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_command</span><span class="params">()</span>:</span></div><div class="line">    <span class="string">'''调用cmd执行接口测试命令'''</span></div><div class="line">    command = <span class="string">r'newman run E:\api_collection\test.postman_collection.json -e E:\api_collection\测试环境.postman_environment.json -r html,json,junit,cli --reporter-html-export E:\api_collection\report\report.html --reporter-json-export E:\api_collection\report\report.json --reporter-junit-export E:\api_collection\report\report.xml'</span></div><div class="line">    print(os.system(command))</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">html_report</span><span class="params">(testreport)</span>:</span> <span class="comment">#这个参数填写的是测试报告所在的目录</span></div><div class="line">    <span class="string">'''在本地找到html测试报告'''</span></div><div class="line">    lists = os.listdir(testreport)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> lists:</div><div class="line">        <span class="keyword">if</span> <span class="string">'.html'</span> <span class="keyword">in</span> i:</div><div class="line">            html_report = os.path.join(testreport,i) <span class="comment">#获取html格式的测试报告</span></div><div class="line">            print(html_report)</div><div class="line">            <span class="keyword">return</span> html_report</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">pass</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_mail</span><span class="params">(html_report)</span>:</span></div><div class="line">    <span class="string">'''发送邮件'''</span></div><div class="line">    <span class="comment">#创建一个带附件的实例</span></div><div class="line">    msg = MIMEMultipart()</div><div class="line">    msg[<span class="string">'Subject'</span>] = Header(<span class="string">'自动化测试报告'</span>,<span class="string">'utf-8'</span>) <span class="comment">#这个是邮件主题名称</span></div><div class="line">    msg[<span class="string">'From'</span>] = Header(<span class="string">'peili'</span>,<span class="string">'utf-8'</span>)</div><div class="line">    msg[<span class="string">'To'</span>] = Header(<span class="string">'ceshi'</span>,<span class="string">'utf-8'</span>)</div><div class="line"></div><div class="line">    <span class="comment">#邮件正文内容</span></div><div class="line">    msg.attach(MIMEText(<span class="string">'瑞云测试组接口测试8月分享(报告在附件)'</span>,<span class="string">'html'</span>,<span class="string">'utf-8'</span>)) <span class="comment">#第二个参数是邮件格式，可以换成其他的比如说'html'，'base64'，'plain'等</span></div><div class="line"></div><div class="line">    <span class="comment">#添加附件</span></div><div class="line">    file1 = MIMEText(open(html_report,<span class="string">'rb'</span>).read(),<span class="string">'base64'</span>,<span class="string">'utf-8'</span>)</div><div class="line">    file1[<span class="string">'Content-Type'</span>] = <span class="string">'application/octet-stream'</span></div><div class="line">    file1[<span class="string">"Content-Disposition"</span>] = <span class="string">'attachment; filename="report.html"'</span> <span class="comment">#这里的filename就是邮件中附件的名字，可以自己命名</span></div><div class="line">    msg.attach(file1)</div><div class="line"></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        smtp = smtplib.SMTP_SSL(<span class="string">'smtp.exmail.qq.com'</span>, <span class="number">465</span>)  <span class="comment">#QQ邮箱发送服务器以及端口，SMTP默认端口是25，这里改成465</span></div><div class="line">        smtp.login(<span class="string">'zuowang@xxx.com'</span>, <span class="string">'password'</span>) <span class="comment">#如果是QQ邮箱的话，第二个参数不是直接用的密码，用的是QQ邮箱的授权码</span></div><div class="line">        smtp.sendmail(sender, receiver, msg.as_string()) <span class="comment">#前两个参数分别是发送邮箱和接收邮箱</span></div><div class="line">        smtp.quit()</div><div class="line">        print(<span class="string">'测试报告邮件发送成功'</span>)</div><div class="line">    <span class="keyword">except</span> smtplib.SMTPException <span class="keyword">as</span> e:</div><div class="line">        print(e)</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    test_command()</div><div class="line">    html_report = html_report(testreport)</div><div class="line">    send_mail(html_report)</div></pre></td></tr></table></figure><hr><font color="white">xx</font><p><div class="paginator"><a href="/archives/" class="all">more</a></div><footer><div class="copyright container"><p>    .</p></div></footer></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇文章&lt;a href=&quot;http://zuowangzuowang.top/2017/08/24/postman%E6%8E%A5%E5
      
    
    </summary>
    
    
      <category term="自动化" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="测试" scheme="http://yoursite.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="邮件" scheme="http://yoursite.com/tags/%E9%82%AE%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>postman接口用例批量执行(Newman)</title>
    <link href="http://yoursite.com/2017/08/24/postman%E6%8E%A5%E5%8F%A3%E7%94%A8%E4%BE%8B%E6%89%B9%E9%87%8F%E6%89%A7%E8%A1%8C/"/>
    <id>http://yoursite.com/2017/08/24/postman接口用例批量执行/</id>
    <published>2017-08-24T10:30:00.000Z</published>
    <updated>2018-07-23T16:10:33.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇<a href="http://lipeilipei.top/2017/08/22/postman%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/" target="_blank" rel="external">《postman简单使用》</a>文章讲了postman的基本用法以及自带的批量执行方式，这种方式简单有效，但是做自动化就有一定的局限了，这篇文章主要是newman的用法，将postman用例导出，用newman在Windows命令行来执行，并且生成测试报告。</p><h2 id="Newman的安装"><a href="#Newman的安装" class="headerlink" title="Newman的安装"></a>Newman的安装</h2><h5 id="1-安装Node-js"><a href="#1-安装Node-js" class="headerlink" title="1.安装Node.js"></a>1.安装Node.js</h5><p>官网地址：<a href="https://nodejs.org/en/download/" target="_blank" rel="external">https://nodejs.org/en/download/</a><br><img src="http://otlbf411d.bkt.clouddn.com/17-8-24/58941664.jpg" alt="Node.js"><br>在Node.js官网选择合适的版本，我这里选择的是Windows平台64位的，下载完成后安装，一路点击下一步就好。<br>安装完后在cmd里面运行<code>node -v</code>,出现以下版本号信息就是安装成功。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">C:\windows\system32&gt;node -v</div><div class="line">v6.11.1</div></pre></td></tr></table></figure></p><h5 id="2-安装Newman"><a href="#2-安装Newman" class="headerlink" title="2.安装Newman"></a>2.安装Newman</h5><p>Node.js已经自带了npm，因此直接在命令行直接输入以下命令，等待安装完成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g newman</div></pre></td></tr></table></figure></p><p>安装完成后，在命令行输入<code>newman -v</code>,出现下面版本号信息就是已经安装成功。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">C:\windows\system32&gt;newman -v</div><div class="line">3.8.0</div></pre></td></tr></table></figure></p><h2 id="Newman命令"><a href="#Newman命令" class="headerlink" title="Newman命令"></a>Newman命令</h2><p>这里只写以下最常用的命令及参数，更多详情参考<a href="https://www.npmjs.com/package/newman" target="_blank" rel="external">Newman官方文档</a>。</p><h5 id="1-最简单的命令"><a href="#1-最简单的命令" class="headerlink" title="1.最简单的命令"></a>1.最简单的命令</h5><p>任何路径下打开cmd里面输入这个命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">newman run E:\api_collection\test.postman_collection.json -e E:\api_collection\测试环境.postman_environment.json</div></pre></td></tr></table></figure></p><p><code>E:\api_collection\test.postman_collection.json</code>就是<a href="http://lipeilipei.top/2017/08/22/postman%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/" target="_blank" rel="external">上一篇</a>文章最后面导出到本地的接口用例collection<br><br><code>E:\api_collection\测试环境.postman_environment.json</code>是<a href="http://lipeilipei.top/2017/08/22/postman%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/" target="_blank" rel="external">上一篇</a>文章最后面导出的环境配置信息<br><br>执行完毕后可以直接在cmd窗口看到如下测试结果，但是用例较多的时候就不方便看了，因此在本地生成测试报告会更好。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">C:\windows\system32&gt;newman run E:\api_collection\test.postman_collection.json -e E:\api_collection\测试环境.postman_environment.json</div><div class="line">newman</div><div class="line"></div><div class="line">test</div><div class="line"></div><div class="line">→ test_linshi</div><div class="line">  POST 10.60.xx.xx:8888/api/test/user/userLogin  [500 Internal Server Error, 327B, 124ms]</div><div class="line">  √  Status code is 200</div><div class="line">  √  Body matches string</div><div class="line"></div><div class="line">┌─────────────────────────┬──────────┬──────────┐</div><div class="line">│                         │ executed │   failed │</div><div class="line">├─────────────────────────┼──────────┼──────────┤</div><div class="line">│              iterations │        1 │        0 │</div><div class="line">├─────────────────────────┼──────────┼──────────┤</div><div class="line">│                requests │        1 │        0 │</div><div class="line">├─────────────────────────┼──────────┼──────────┤</div><div class="line">│            test-scripts │        1 │        0 │</div><div class="line">├─────────────────────────┼──────────┼──────────┤</div><div class="line">│      prerequest-scripts │        0 │        0 │</div><div class="line">├─────────────────────────┼──────────┼──────────┤</div><div class="line">│              assertions │        2 │        0 │</div><div class="line">├─────────────────────────┴──────────┴──────────┤</div><div class="line">│ total run duration: 204ms                     │</div><div class="line">├───────────────────────────────────────────────┤</div><div class="line">│ total data received: 118B (approx)            │</div><div class="line">├───────────────────────────────────────────────┤</div><div class="line">│ average response time: 124ms                  │</div><div class="line">└───────────────────────────────────────────────┘</div></pre></td></tr></table></figure></p><h5 id="2-执行多次"><a href="#2-执行多次" class="headerlink" title="2.执行多次"></a>2.执行多次</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">newman run E:\api_collection\test.postman_collection.json -n 10</div></pre></td></tr></table></figure><p>在上一个命令的后面加上<code>-n 10</code>，也就是这条测试命令运行10次。</p><h5 id="3-生成测试报告"><a href="#3-生成测试报告" class="headerlink" title="3.生成测试报告"></a>3.生成测试报告</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">newman run E:\api_collection\test.postman_collection.json -e E:\api_collection\测试环境.postman_environment.json -r html,json,junit --reporter-json-export jsonOut.json --reporter-junit-export xmlOut.xml --reporter-html-export htmlOut.html</div></pre></td></tr></table></figure><p><code>-r html,json,junit</code> 指定我要生成html，json，xml这三种形式的测试报告<br><br><code>--reporter-json-export jsonOut.json</code>   生成json格式的测试报告，报告名前面没有添加路径的话就会生成在执行命令所在的当前目录<br><br><code>--reporter-junit-export xmlOut.xml</code>    生成xml格式的测试报告<br><br><code>--reporter-html-export htmlOut.html</code>   生成html格式的测试报告<br></p><h5 id="生成结果如下："><a href="#生成结果如下：" class="headerlink" title="生成结果如下："></a>生成结果如下：</h5><p><img src="http://otlbf411d.bkt.clouddn.com/17-8-24/18866706.jpg" alt="测试报告"></p><hr><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p><a href="http://lipeilipei.top/2017/08/07/postman/" target="_blank" rel="external">postman安装以及问题</a><br><a href="http://lipeilipei.top/2017/08/22/postman%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/" target="_blank" rel="external">postman简单使用</a><br><a href="http://lipeilipei.top/2017/08/25/windows%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%92%8Cpython%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/" target="_blank" rel="external">定时任务与Python发送邮件</a></p><font color="white">xx</font><p><div class="paginator"><a href="/archives/" class="all">more</a></div><footer><div class="copyright container"><p>    .</p></div></footer></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇&lt;a href=&quot;http://lipeilipei.top/2017/08/22/postman%E7%AE%80%E5%8D%95
      
    
    </summary>
    
    
      <category term="测试" scheme="http://yoursite.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="接口测试" scheme="http://yoursite.com/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
      <category term="postman" scheme="http://yoursite.com/tags/postman/"/>
    
      <category term="工具使用" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
      <category term="newman" scheme="http://yoursite.com/tags/newman/"/>
    
  </entry>
  
  <entry>
    <title>postman简单使用</title>
    <link href="http://yoursite.com/2017/08/22/postman%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/08/22/postman简单使用/</id>
    <published>2017-08-22T10:30:00.000Z</published>
    <updated>2018-07-23T16:04:51.681Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇文章<a href="http://lipeilipei.top/2017/08/07/postman/" target="_blank" rel="external">《postman安装以及问题》</a>已经说明了如何安装好postman，现在写一下postman的使用，它用法非常丰富多样，这里只举简单的例子来说明大致的操作流程，包括请求、断言、保存、批量执行、导入导出等。</p><h2 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h2><p><img src="http://otlbf411d.bkt.clouddn.com/17-8-28/51994249.jpg" alt=""><br>上图就是一个最简单的GET请求，请求方法下拉框选择GET，接口地址栏填写需要请求的接口，我这里直接写了百度的主页，然后点击Send就完成了请求。<br>下方是请求的结果，可以看到右侧状态码是200状态证明请求成功，请求返回值是一个html。<br>页面最左侧有history请求历史栏，可以在这里找已经发送过的所有请求，选择点击以后可以重复请求。</p><h2 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h2><p><img src="http://otlbf411d.bkt.clouddn.com/17-8-28/85013672.jpg" alt=""><br><img src="http://otlbf411d.bkt.clouddn.com/17-8-28/47166063.jpg" alt=""><br>在请求方法下拉框选择POST方法，接口地址栏填写需要请求的接口，然后填写请求参数。<br>在请求的body部分点击form-data，以key-value样式请求参数。<br>或者点击raw，以json格式填写请求参数，开发给的接口文档里面参数哦较多的话一般以json格式书写，所以只要复制粘贴过来填写到body部分的raw栏下就可以。</p><h2 id="请求断言"><a href="#请求断言" class="headerlink" title="请求断言"></a>请求断言</h2><p>设置了断言以后能清楚的看出这个请求是否通过，也是后面做自动化的必备条件。<br><img src="http://otlbf411d.bkt.clouddn.com/17-8-28/28174441.jpg" alt=""><br>点击请求的test栏，在输入框填写断言，这里的写法都是js格式的，但是也不用担心写起来麻烦，因为常用的断言postman已经在右侧给出了现成的写法，点击一下就可以自动填写到test栏下。比如我这里选择<code>Status code：Code is 200</code>来判断请求返回的状态码是不是200，点击send请求之后可以在下方请求结果的Test栏看到结果是失败的，因为这个接口还没有开发完成，状态码返回的是500。</p><h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><p>一般测试环境、开发环境、线上环境的环境是独立开来的，设置好环境变量以后，接口地址稍做调整，请求的时候选择对应的环境就能很方便的切换到不同的环境来测试。<br></p><h5 id="1-点击下图中所示的小齿轮按钮，然后点击Manage-Enviroments"><a href="#1-点击下图中所示的小齿轮按钮，然后点击Manage-Enviroments" class="headerlink" title="1.点击下图中所示的小齿轮按钮，然后点击Manage Enviroments"></a>1.点击下图中所示的小齿轮按钮，然后点击Manage Enviroments</h5><p><img src="http://otlbf411d.bkt.clouddn.com/17-8-28/19166911.jpg" alt=""></p><h5 id="2-在Manage-Enviroments栏下点击Add"><a href="#2-在Manage-Enviroments栏下点击Add" class="headerlink" title="2.在Manage Enviroments栏下点击Add"></a>2.在Manage Enviroments栏下点击Add</h5><p><img src="http://otlbf411d.bkt.clouddn.com/17-8-28/12124110.jpg" alt=""></p><h5 id="3-编辑环境的名称以及接口名称和IP端口，点击Update保存"><a href="#3-编辑环境的名称以及接口名称和IP端口，点击Update保存" class="headerlink" title="3.编辑环境的名称以及接口名称和IP端口，点击Update保存"></a>3.编辑环境的名称以及接口名称和IP端口，点击Update保存</h5><p><img src="http://otlbf411d.bkt.clouddn.com/17-8-28/50941862.jpg" alt=""></p><h5 id="4-修改请求url"><a href="#4-修改请求url" class="headerlink" title="4.修改请求url"></a>4.修改请求url</h5><p>返回到postman主页面，将接口前面的IP和端口换成刚刚设置好的环境的key，写在两对大括号里面，可以看到字体自动变成了橙色，鼠标放到上面能看到这个key所对应的value，也就是IP和端口。<br>然后在环境下拉框选择想要测试的环境，我这里选择的是编辑好的测试环境，这个时候请求就会在测试环境请求了，想要在线上测试的话，就在环境下拉框选择编辑好的线上环境就好了。<br><img src="http://otlbf411d.bkt.clouddn.com/17-8-28/25457651.jpg" alt=""></p><h2 id="保存到接口集合"><a href="#保存到接口集合" class="headerlink" title="保存到接口集合"></a>保存到接口集合</h2><p>大部分情况下，一个系统模块有很多个接口，把请求都放在该模块的一个集合下方便管理。</p><h5 id="1-左侧切换到collections栏，点击添加按钮"><a href="#1-左侧切换到collections栏，点击添加按钮" class="headerlink" title="1.左侧切换到collections栏，点击添加按钮"></a>1.左侧切换到collections栏，点击添加按钮</h5><p><img src="http://otlbf411d.bkt.clouddn.com/17-8-28/41815874.jpg" alt=""></p><h5 id="2-填写集合名称和集合描述并保存"><a href="#2-填写集合名称和集合描述并保存" class="headerlink" title="2.填写集合名称和集合描述并保存"></a>2.填写集合名称和集合描述并保存</h5><p><img src="http://otlbf411d.bkt.clouddn.com/17-8-28/31456894.jpg" alt=""></p><h5 id="3-点击请求右侧的save按钮，点击save-as"><a href="#3-点击请求右侧的save按钮，点击save-as" class="headerlink" title="3.点击请求右侧的save按钮，点击save as"></a>3.点击请求右侧的save按钮，点击save as</h5><p><img src="http://otlbf411d.bkt.clouddn.com/17-8-28/37323875.jpg" alt=""></p><h5 id="4-弹窗内填写请求的名称和描述等，下方选择点击刚刚创建的集合并保存"><a href="#4-弹窗内填写请求的名称和描述等，下方选择点击刚刚创建的集合并保存" class="headerlink" title="4.弹窗内填写请求的名称和描述等，下方选择点击刚刚创建的集合并保存"></a>4.弹窗内填写请求的名称和描述等，下方选择点击刚刚创建的集合并保存</h5><p><img src="http://otlbf411d.bkt.clouddn.com/17-8-28/51094758.jpg" alt=""></p><h2 id="批量执行请求"><a href="#批量执行请求" class="headerlink" title="批量执行请求"></a>批量执行请求</h2><p>postman自带的runner可以批量执行一个集合的接口用例</p><h5 id="1-点击主页左上方的Runner"><a href="#1-点击主页左上方的Runner" class="headerlink" title="1.点击主页左上方的Runner"></a>1.点击主页左上方的Runner</h5><p><img src="http://otlbf411d.bkt.clouddn.com/17-8-28/31671649.jpg" alt=""></p><h5 id="2-选择集合"><a href="#2-选择集合" class="headerlink" title="2.选择集合"></a>2.选择集合</h5><ul><li>选择点击刚刚创建的test111集合</li><li>Environment勾选需要测试的环境</li><li>Iteration是执行测试，这里就执行一次就好</li><li>点击Start Run就开始执行，右侧能看到请求结果，最上方是汇总</li></ul><p><img src="http://otlbf411d.bkt.clouddn.com/17-8-28/64864625.jpg" alt=""></p><h2 id="导出与导入"><a href="#导出与导入" class="headerlink" title="导出与导入"></a>导出与导入</h2><p>postman能很方便的将接口测试集合导出到本地，同样的也能从本地导入进来。</p><h5 id="导出collection与环境变量"><a href="#导出collection与环境变量" class="headerlink" title="导出collection与环境变量"></a>导出collection与环境变量</h5><p>1.点击请求集合右侧的三个点 -&gt; Export<br><img src="http://otlbf411d.bkt.clouddn.com/17-8-28/54675693.jpg" alt=""></p><p>2.弹窗点击Export<br>这里有collection v1和collection v2两种模式，v2模式导出的东西更多，一般选择v1就可以了。<br><img src="http://otlbf411d.bkt.clouddn.com/17-8-28/56468788.jpg" alt=""></p><p>3.在环境变量设置这里选择要导出的环境，点击右侧向下箭头即可将环境保存到本地。<br><img src="http://otlbf411d.bkt.clouddn.com/17-8-28/87265381.jpg" alt=""></p><p>4.导出到本地的请求集合和环境都是json格式的文件<br><img src="http://otlbf411d.bkt.clouddn.com/17-8-28/47983745.jpg" alt=""></p><h5 id="导入Collection"><a href="#导入Collection" class="headerlink" title="导入Collection"></a>导入Collection</h5><p>直接点击postman左上方的Import按钮，在本地选择collection即可<br><img src="http://otlbf411d.bkt.clouddn.com/17-8-28/85852094.jpg" alt=""><br><img src="http://otlbf411d.bkt.clouddn.com/17-8-28/66457656.jpg" alt=""></p><h2 id="注册登陆"><a href="#注册登陆" class="headerlink" title="注册登陆"></a>注册登陆</h2><p>不登录并不会影响工具的使用，但是登陆以后接口测试用例都可以保存到账号里面，不管是在那个电脑上登陆自己的账号就都能看到已经保存的接口测试集合，所以还是推荐登陆账号使用，谷歌邮箱可以直接登陆，支持国内的QQ邮箱等注册登陆。</p><hr><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p><div class="paginator"><a href="/archives/" class="all">more</a></div><footer><div class="copyright container"><p>    .</p></div></footer></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇文章&lt;a href=&quot;http://lipeilipei.top/2017/08/07/postman/&quot; target=&quot;_blan
      
    
    </summary>
    
    
      <category term="测试" scheme="http://yoursite.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="接口测试" scheme="http://yoursite.com/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
      <category term="postman" scheme="http://yoursite.com/tags/postman/"/>
    
      <category term="工具使用" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>mongodb安装及可能出现的问题</title>
    <link href="http://yoursite.com/2017/08/15/mongodb%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2017/08/15/mongodb安装/</id>
    <published>2017-08-14T17:03:00.000Z</published>
    <updated>2018-07-23T16:05:32.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>下载mongodb</li><li>配置</li><li>启动mongodb</li><li>进入mongodb</li><li>注册为Windows服务</li><li>可能出现的问题</li></ul><h2 id="一、下载mongodb"><a href="#一、下载mongodb" class="headerlink" title="一、下载mongodb"></a>一、下载mongodb</h2><p><a href="https://www.mongodb.com/download-center#community" target="_blank" rel="external">进入官网</a>，选择适合的版本并下载到本地，不同操作系统，32位64位都有对应的安装包，比如我下载的是msi格式的安装程序，下载后直接双击运行安装，我安装的路径是 D:\application\mongodb。<br><img src="http://otlbf411d.bkt.clouddn.com/17-8-15/1622487.jpg" alt="mongodb官网"></p><h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p>1.在D:\application\mongodb路径下新建一个Data目录<br><img src="http://otlbf411d.bkt.clouddn.com/17-8-15/65377691.jpg" alt=""></p><p>2.继续进入Data目录创建一个db目录，一个log目录<br><img src="http://otlbf411d.bkt.clouddn.com/17-8-15/28424143.jpg" alt=""></p><p>3.继续进入log目录新建一个MongoDB.log的文件<br><img src="http://otlbf411d.bkt.clouddn.com/17-8-15/505345.jpg" alt=""></p><h2 id="三、启动mongodb"><a href="#三、启动mongodb" class="headerlink" title="三、启动mongodb"></a>三、启动mongodb</h2><p>用管理员身份启动cmd，cd进入D:\application\mongodb\bin，<br>输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongod.exe -dbpath &quot;D:\application\mongodb\Data\db&quot;</div></pre></td></tr></table></figure></p><p>作用：将mongodb的数据库文件创建到D:\application\mongodb\Data\db目录<br>注意：<br>1、注意是mongod.exe，不是mongo.exe，不要搞混了。<br>2、此时界面最后一行会显示<br><code>waiting for connections on port 27017</code>则表示数据库已经启动成功。<br><img src="http://otlbf411d.bkt.clouddn.com/17-8-15/13192196.jpg" alt=""></p><h2 id="四、进入mongodb"><a href="#四、进入mongodb" class="headerlink" title="四、进入mongodb"></a>四、进入mongodb</h2><p>仍然是在bin目录下，新建一个cmd窗口，运行mongo.exe（注意跟mongod.exe区分开）就进入了mongodb交互界面。<br><img src="http://otlbf411d.bkt.clouddn.com/17-8-15/59316733.jpg" alt=""></p><h2 id="五、注册为Windows服务"><a href="#五、注册为Windows服务" class="headerlink" title="五、注册为Windows服务"></a>五、注册为Windows服务</h2><p>1.用管理员身份（必须是管理员）启动cmd，进入D:\application\mongodb\bin，<br>2.输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongod.exe -dbpath &quot;D:\application\mongodb\Data\db&quot; -logpath &quot;D:\application\mongodb\Data\log\MongoDB.log&quot; -install -serviceName &quot;MongoDB&quot;</div></pre></td></tr></table></figure></p><p>此时服务就已经安装成功。<br>运行<code>net start mongodb</code>(开启服务)<br><img src="http://otlbf411d.bkt.clouddn.com/17-8-15/70565959.jpg" alt=""></p><p>相应的<code>net stop mongodb</code>(关闭服务)<br><img src="http://otlbf411d.bkt.clouddn.com/17-8-15/91019319.jpg" alt=""></p><h2 id="六、可能遇到的问题"><a href="#六、可能遇到的问题" class="headerlink" title="六、可能遇到的问题"></a>六、可能遇到的问题</h2><h5 id="1-操作被拦截"><a href="#1-操作被拦截" class="headerlink" title="1.操作被拦截"></a>1.操作被拦截</h5><p>操作被拦截在操作过程中电脑管家，安全卫士等软件会拦截操作，一律允许，或者操作之前先把这些软件完全退出（其实可以直接卸载掉这些用处不是很大的软件）。</p><h5 id="2-服务注册失败"><a href="#2-服务注册失败" class="headerlink" title="2.服务注册失败"></a>2.服务注册失败</h5><p>服务注册失败，查看在D:\application\mongodb\Data\log\MongoDB.log里面记录的信息为<code>“Error connecting to the Service Control Manager: 拒绝访问”</code><br>这种情况就是因为cmd不是通过管理员方式启动的，没有权限造成的，所以为了以防万一，上面所有的cmd操作都用管理员方式打开。</p><h5 id="3-服务启动失败"><a href="#3-服务启动失败" class="headerlink" title="3.服务启动失败"></a>3.服务启动失败</h5><p>服务注册完成后，运行命令net start mongodb启动服务可能会失败，这个时候去删掉db目录下这两个文件再重新启动服务就好了<br>D:\application\mongodb\Data\db<br>mongod.lock<br>storage.bson<br><img src="http://otlbf411d.bkt.clouddn.com/17-8-15/91720144.jpg" alt=""></p><font color="white">xx</font><p><div class="paginator"><a href="/archives/" class="all">more</a></div><footer><div class="copyright container"><p>    .</p></div></footer></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;下载mongodb&lt;/li&gt;
&lt;li&gt;配置&lt;/li&gt;
&lt;li&gt;启动mongodb&lt;/li&gt;
&lt;li&gt;进入mongodb&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mongodb" scheme="http://yoursite.com/tags/mongodb/"/>
    
      <category term="Web开发" scheme="http://yoursite.com/tags/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>postman安装以及问题</title>
    <link href="http://yoursite.com/2017/08/07/postman/"/>
    <id>http://yoursite.com/2017/08/07/postman/</id>
    <published>2017-08-07T04:30:00.000Z</published>
    <updated>2018-07-23T16:04:42.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>一、native版（推荐）</li><li>二、chrome版在线安装（官方不再更新维护）</li><li>三、chrome版本地安装</li></ul><h2 id="一、native版"><a href="#一、native版" class="headerlink" title="一、native版"></a>一、native版</h2><p>这个版本是直接下载安装包在本地安装即可，有Windows，MacOS，Linux版本。<br>进入<a href="https://www.getpostman.com/" target="_blank" rel="external">官网地址</a>，这里我选择Windows版本64位，下载到本地正常安装打开即可，启动后软件上方有菜单栏，这也是native版与chrome版本的区别之一。<br><img src="http://otlbf411d.bkt.clouddn.com/17-8-25/67710064.jpg" alt="postman native版"><br><img src="http://otlbf411d.bkt.clouddn.com/17-8-25/5052343.jpg" alt="postman native版"></p><h2 id="二、chrome版在线安装"><a href="#二、chrome版在线安装" class="headerlink" title="二、chrome版在线安装"></a>二、chrome版在线安装</h2><p>如果可以科学上网的话，最方便的就是直接在谷歌浏览器应用商店搜索postman，安装这两个插件即可。然后在应用里面就可以找到postman,右键postman图标，点击“创建快捷方式”可以在桌面创建postman图标。<br><img src="http://otlbf411d.bkt.clouddn.com/17-8-7/90487.jpg" alt="chrome应用商店"><br><img src="http://otlbf411d.bkt.clouddn.com/17-8-7/50332358.jpg" alt="postman打开方式"></p><h2 id="三、chrome版本地安装"><a href="#三、chrome版本地安装" class="headerlink" title="三、chrome版本地安装"></a>三、chrome版本地安装</h2><p>大部分chrome浏览器插件都可以利用直接拖拽.crx插件到浏览器的方式安装，但是有些插件比较特殊不能这样安装成功，postman就是其中之一。</p><h5 id="1-安装postman"><a href="#1-安装postman" class="headerlink" title="1.安装postman"></a>1.安装postman</h5><p>下载已经打包好的postman插件，注意是.zip的压缩包，不是.crx格式的文件。<br>（我已经打包好最新的5.1.3版本放在百度云，链接: <a href="https://pan.baidu.com/s/1kVQMrL9" target="_blank" rel="external">https://pan.baidu.com/s/1kVQMrL9</a> 密码: r5rn）<br>下载完成后解压该文件，然后把其中“_metadata”文件夹的名称修改为“metadata”，也就是去掉前面的小横线，不修改的话可能会报错（注：插件安装以后这个文件夹不能删除，建议放在不经常变动的地方）。<br><img src="http://otlbf411d.bkt.clouddn.com/17-8-7/98459863.jpg" alt="加载扩展程序报错"></p><p>在浏览器设置里打开“扩展程序”，或者直接在地址栏输入“chrome://extensions/”进入扩展程序页面。<br>① 在开发者模式前面打上勾<br><br>② 点击加载已解压的扩展程序<br><br>③ 选择刚刚解压出来的文件夹后点击确定就能安装成功<br><img src="http://otlbf411d.bkt.clouddn.com/17-8-7/49138166.jpg" alt="勾选开发者模式"><br><img src="http://otlbf411d.bkt.clouddn.com/17-8-7/17318262.jpg" alt="安装插件成功"></p><h5 id="2-安装Postman-Interceptor插件"><a href="#2-安装Postman-Interceptor插件" class="headerlink" title="2.安装Postman Interceptor插件"></a>2.安装Postman Interceptor插件</h5><p>安装这个插件可以直接从电脑里拖到浏览器扩展程序页面安装</p><hr><p><div class="paginator"><a href="/archives/" class="all">more</a></div><footer><div class="copyright container"><p>    .</p></div></footer></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一、native版（推荐）&lt;/li&gt;
&lt;li&gt;二、chrome版在线安装（官方不再更新维护）&lt;/li&gt;
&lt;li&gt;三、chrome
      
    
    </summary>
    
    
      <category term="测试" scheme="http://yoursite.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="接口测试" scheme="http://yoursite.com/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="postman" scheme="http://yoursite.com/tags/postman/"/>
    
  </entry>
  
</feed>
