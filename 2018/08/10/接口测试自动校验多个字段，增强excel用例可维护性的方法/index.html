<!DOCTYPE html><html prefix="og: http://ogp.me/ns#"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>HTTP接口测试自动校验多个字段，增强excel用例可维护性的方法 · Let's go for a walk around the world - zuo</title><meta name="description" content="HTTP接口测试自动校验多个字段，增强excel用例可维护性的方法 - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="//at.alicdn.com/t/font_1472710214_6648843.css"><link rel="stylesheet" href="//raw.githack.com/xwartz/hexo-theme-nuna/next/source/style/main.css?v=1.0.3"></head><body class="pupa"><div class="loading-bar"></div><main><div class="post post"><article itemscope itemtype="http://schema.org/Article" class="hentry"><div itemprop="image" style="background-image: url(http://otlbf411d.bkt.clouddn.com/18-4-26/72083805.jpg)" class="entry-cover"></div><div class="container"><div class="entry-header"><h1 class="entry-title">HTTP接口测试自动校验多个字段，增强excel用例可维护性的方法</h1><div class="entry-description"></div><div class="entry-meta"><time itemprop="datePublished" datetime="Friday, August 10th 2018, 8:30:00 pm" class="updated">Aug 10, 2018</time><em class="post-count">1,127 words</em></div></div><div itemprop="articleBody" class="entry-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当接口比较多，返回值也比较多，接口自动化测试校验返回值是否符合预期就得在每条测试用例后面添加多个assert校验，几百条用例的时候写校验语句就得上千条，为了简化代码，同时为了方便继续使用现有的excel表维护接口用例，因此将断言的方法重新封装为一个易用的函数来调用。</p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h4 id="整理excel用例"><a href="#整理excel用例" class="headerlink" title="整理excel用例"></a>整理excel用例</h4><p>首先excel中的用例预期结果按照统一的格式来写，这是方便代码获取到预期结果并做下一步操作。<br>例如这一个接口我要检验返回值中的三个字段，分别是code，message，result，预期结果这一栏每个字段后面写上英文冒号以及预期值，三个字段通过换行分隔开。<br><img src="http://otlbf411d.bkt.clouddn.com/18-8-14/59983745.jpg" alt=""></p>
<h4 id="编写公共方法"><a href="#编写公共方法" class="headerlink" title="编写公共方法"></a>编写公共方法</h4><p>这里我新建一个public_data.py文件，在里面编写公共方法。</p>
<h5 id="1-读取excel表公共方法"><a href="#1-读取excel表公共方法" class="headerlink" title="1.读取excel表公共方法"></a>1.读取excel表公共方法</h5><p>这段代码是从excel读取内容的公共方法，它接收三个参数，分别是表的名称、行、列，可以取到具体哪一个框的内容。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_excel</span><span class="params">(sheet,row,col)</span>:</span></div><div class="line">    <span class="string">'''读取excel表公共方法'''</span></div><div class="line">    a = xlrd.open_workbook(<span class="string">'E:/R-Test/datas/test_data.xls'</span>)</div><div class="line">    b = a.sheet_by_name(sheet)</div><div class="line">    c = b.cell_value(row,col)</div><div class="line">    <span class="keyword">return</span> c</div></pre></td></tr></table></figure></p>
<h5 id="2-判断每个接口用例执行几次断言公共方法"><a href="#2-判断每个接口用例执行几次断言公共方法" class="headerlink" title="2.判断每个接口用例执行几次断言公共方法"></a>2.判断每个接口用例执行几次断言公共方法</h5><p>这段代码是校验多个返回字段的公共方法，它接收五个参数，分别是self、表名、行、列、请求返回值。<br>调用上面的读取excel表公共方法，从预期结果栏获取需要校验的字段名，预期值，此方法直接获取到的是一个字符串，现在通过换行符将需要校验的几个字段拆分，然后放入for循环用assert来断言。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">assert_num</span><span class="params">(self,sheet,row,col,result)</span>:</span></div><div class="line">    <span class="string">'''判断每个接口用例执行几次断言'''</span></div><div class="line">    a = read_excel(sheet,row,col).split(<span class="string">'\n'</span>)       <span class="comment">#获取预期结果</span></div><div class="line">    b = read_excel(sheet, row, col+<span class="number">1</span>).split(<span class="string">'\n'</span>)   <span class="comment">#获取结果解释，用于断言失败后打印必要信息</span></div><div class="line">    <span class="keyword">for</span> i,j <span class="keyword">in</span> zip(a,b):</div><div class="line">        r = result[i.split(<span class="string">':'</span>)[<span class="number">0</span>]]                 <span class="comment">#r就是从返回值中取出的要进行校验的字段，result参数是需要传入的接口返回信息。</span></div><div class="line">        <span class="keyword">if</span> type(r) <span class="keyword">is</span> int:                          <span class="comment">#如果返回值取出的数据为int格式，把他转为str，方便跟excel中取出的字符串比较,此框架从excel表中取出的内容为str格式</span></div><div class="line">            r = str(r)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">pass</span></div><div class="line">        self.assertEqual(r, i.split(<span class="string">':'</span>)[<span class="number">1</span>],msg=<span class="string">'['</span>+j+<span class="string">'校验有误]'</span>)</div></pre></td></tr></table></figure></p>
<h5 id="3-优化上一个方法"><a href="#3-优化上一个方法" class="headerlink" title="3.优化上一个方法"></a>3.优化上一个方法</h5><p>实际测试过程中发现有些要校验的字段并不是在接口返回json的第一层，而是嵌套好几层的，例如下面这个接口的status字段。<br><img src="http://otlbf411d.bkt.clouddn.com/18-8-14/39980507.jpg" alt=""></p>
<p>因此需要校验这些字段的话首先要从excel表中拿到正确的字段名，同样在写excel表的时候就按照固定格式，那么用字段名写成这样，每一层中间用短横线’-‘分开，注意如果测试的接口本身字段有短横线要注意区分，换成其他的符号。<br><img src="http://otlbf411d.bkt.clouddn.com/18-8-14/23353913.jpg" alt=""></p>
<p>然后修改上面的代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">assert_num</span><span class="params">(self,sheet,row,col,result,url)</span>:</span></div><div class="line">    <span class="string">'''判断每个接口用例执行几次断言'''</span></div><div class="line">    a = read_excel(sheet,row,col).split(<span class="string">'\n'</span>)       <span class="comment">#获取预期结果</span></div><div class="line">    b = read_excel(sheet, row, col+<span class="number">1</span>).split(<span class="string">'\n'</span>)   <span class="comment">#获取结果解释</span></div><div class="line">    <span class="keyword">for</span> i,j <span class="keyword">in</span> zip(a,b):</div><div class="line">        x = i.split(<span class="string">':'</span>)[<span class="number">0</span>]                         <span class="comment">#x就是从返回值中取出的要进行校验的字段</span></div><div class="line">        <span class="keyword">if</span> <span class="string">'-'</span> <span class="keyword">in</span> x:                                <span class="comment">#判断若excel里面额字段不是一层，则转换成字典连续取值的格式</span></div><div class="line">            y = x.split(<span class="string">'-'</span>)</div><div class="line">            <span class="keyword">for</span> key <span class="keyword">in</span> y:                           <span class="comment">#通过for循环依次获取下一层的字段值</span></div><div class="line">                result = result[key]</div><div class="line">            r = result</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            r = result[x]</div><div class="line">        <span class="keyword">if</span> type(r) <span class="keyword">is</span> int:                          <span class="comment">#如果返回值取出的数据为int格式，把他转为str，方便跟excel中取出的字符串比较,此框架从excel表中取出的内容为str格式</span></div><div class="line">            r = str(r)</div><div class="line">        <span class="keyword">if</span> type(r) <span class="keyword">is</span> bool:                         <span class="comment">#有些接口返回值是布尔值，转换成字符串</span></div><div class="line">            r = str(r)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">pass</span></div><div class="line">        self.assertIn(i.split(<span class="string">':'</span>)[<span class="number">1</span>], r,msg=<span class="string">'['</span>+j+<span class="string">'校验有误]'</span>+url)</div></pre></td></tr></table></figure></p>
<h2 id="在接口测试用例中调用"><a href="#在接口测试用例中调用" class="headerlink" title="在接口测试用例中调用"></a>在接口测试用例中调用</h2><p>在测试用例所在的文件中导入公共方法，然后在接口测试用例执行完毕后调用断言校验的方法就可以自动判断有几条字段需要校验，分别校验并打印结果。<br><img src="http://otlbf411d.bkt.clouddn.com/18-8-14/89025849.jpg" alt=""></p>
</div><div class="entry-extra"><div class="entry-tags"><a href="/tags/python/" class="tag">python</a><a href="/tags/unittest/" class="tag">unittest</a><a href="/tags/excel/" class="tag">excel</a></div></div></div></article></div></main><footer><div class="copyright container"><p>© Copyright 2018 by <a href="http://yoursite.com">John Doe</a>.</p></div></footer><script async src="//cdn.bootcss.com/mathjax/2.7.0-beta.0/MathJax.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-69822347-1",'auto');
ga('set', 'appName',"Let's go for a walk around the world - zuo");
ga('send','pageview');</script><script>(function () { var sid =500303098;cid =500303108;var hm = document.createElement('script');
hm.src = 'http://pingjs.qq.com/h5/stats.js';
hm.setAttribute('name', 'MTAH5'); hm.setAttribute('sid', sid); hm.setAttribute('cid', cid);
var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);
}())</script><script>var _vds = _vds || [];
window._vds = _vds;
(function(){
  ;_vds.push(['setAccountId',"90b580e047dd0007"  ]);
  (function() {
      var vds = document.createElement('script');
      vds.type='text/javascript';
      vds.async = true;
      vds.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'dn-growing.qbox.me/vds.js';
      var s = document.getElementsByTagName('script')[0];
      s.parentNode.insertBefore(vds, s);
  })();
})();</script><script async src="//raw.githack.com/Easyfood/pageAccelerator/master/dist/page-accelerator.min.js"></script><script async src="/script/loading.js"></script><script async src="/script/photo.js"></script></body></html>